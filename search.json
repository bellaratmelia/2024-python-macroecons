[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SEIC x DSA Python for Macroeconomics Workshop 2024",
    "section": "",
    "text": "This site serves as a repository for the slides and codes developed for the ‘Macroeconomics with Python Workshop’ for SEIC x DSA club members at SMU.\nInstructor: Bella Ratmelia, Research & Data Services, SMU Libraries\nTeaching Assistants:\n\nRein Alfri (SOE)\nAnya Dharsan (SCIS)\nSomesh Balamurugan (SOE)\nTay Mui Yen (SMU Libraries)\nTee Lip Hwee (SMU Libraries)"
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "SEIC x DSA Python for Macroeconomics Workshop 2024",
    "section": "",
    "text": "This site serves as a repository for the slides and codes developed for the ‘Macroeconomics with Python Workshop’ for SEIC x DSA club members at SMU.\nInstructor: Bella Ratmelia, Research & Data Services, SMU Libraries\nTeaching Assistants:\n\nRein Alfri (SOE)\nAnya Dharsan (SCIS)\nSomesh Balamurugan (SOE)\nTay Mui Yen (SMU Libraries)\nTee Lip Hwee (SMU Libraries)"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "SEIC x DSA Python for Macroeconomics Workshop 2024",
    "section": "Schedule",
    "text": "Schedule\nSlides will be progressively made available below.\n\n\n\n\nDate and Time\nVenue\nTopic & Slides\nQuiz\n\n\n\n\nSat, 7 Sep 2024, 10 AM - 12 PM\nYPHSL Seminar Room 3-12\nPython basics\nQuiz 1\n\n\nSat, 14 Sep 2024, 10 AM - 12 PM\nSOSS/CIS Seminar Room 3-1\nIntroduction to Numpy and Matplotlib\nQuiz 2\n\n\nSat, 28 Sep 2024, 10 AM - 12 PM\nSOSS/CIS Seminar Room 3-1\nData wrangling and timeseries with Dataframe\nQuiz 3\n\n\nSat, 5 Oct 2024, 10 AM - 12 PM\nSOSS/CIS Seminar Room 3-1\nRetrieve data with APIs and putting it all together\n\n\n\n\n\n\n\n\n\n\n\n\nImportant - Please bring your laptop & charger to the workshop\n\n\n\nAs this is a hands-on workshop, please do bring your laptop. Tablets like Surface or iPad will not be sufficient as they could not run Visual Studio Code."
  },
  {
    "objectID": "index.html#pre-workshop-activities",
    "href": "index.html#pre-workshop-activities",
    "title": "SEIC x DSA Python for Macroeconomics Workshop 2024",
    "section": "Pre-workshop activities",
    "text": "Pre-workshop activities\nThis workshop will use Visual Studio Code, or VS Code. It is a free, versatile code editor that supports many programming languages, including Python. It offers a user-friendly interface for writing and running Python code, and with the right extensions, it can also handle Jupyter notebooks!\nPlease install the following things in your laptop before the workshop:\n\nDownload and install the latest python3 for your machine (should be version 3.12 or thereabouts).\n\nIf you are on Windows, at the start of the installation, tick the “Add Python 3.12 to PATH”.\n\nDownload and install Visual Studio Code. Check out the setup instructions for Windows and macOS\nOnce you’ve installed Visual Studio code, start it up. Open the Extension tab on the left sidebar (Ctrl + Shift + X on Windows or Cmd + Shift + X on macOS) and install the Python and Jupyter extension. (The extension creator should be Microsoft)\n\n\n\nFill up the pre-workshop survey! Please fill this up before the beginning of session 1."
  },
  {
    "objectID": "index.html#datasets",
    "href": "index.html#datasets",
    "title": "SEIC x DSA Python for Macroeconomics Workshop 2024",
    "section": "Datasets",
    "text": "Datasets\n\n\n\n\n\n\nWhat is a CSV?\n\n\n\nA CSV (Comma-Separated Values) file is a type of file that stores data in a plain text format. Each line in the file represents a row of data, and within each row, individual pieces of data (like numbers or words) are separated by commas.\nThis format is commonly used for storing and transferring data, especially in spreadsheets and databases. Because it is literally just plain text, it is an ideal format if you have large amount of data.\nYou can open CSV files in Excel, Google Sheets, or even Notepad!\n\n\n\nDataset 1: sg-gdp.csv\nFor session 2 of this workshop, we will be using small dataset stored in a CSV file called sg-gdp.csv.\nClick here to open sg-gdp.csv, and then Ctrl + S / Cmd + S to save it locally into your data folder\n\n\nDataset 2: unemployment-age.csv\nFor session 3 of this workshop, we will be using small dataset stored in a CSV file called unemployment-age.csv. This is a time series data that tracks unemployment rate for various age groups in United States, retrieved from Federal Reserve Economic Data (FRED).\nClick here to open unemployment-age.csv, and then Ctrl + S / Cmd + S to save it locally into your data folder"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html",
    "href": "for-tas/03-pandas-notes.html",
    "title": "Dataframe with Pandas",
    "section": "",
    "text": "pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language. 1 pandas aims to be the fundamental high-level building block for doing practical, real world data analysis in Python.\n\n\nWell-established Python library for data manipulation and analysis\nBuilt on top of NumPy. Unlike Numpy who can be difficult to “read”, Dataframe presents data in tabular format that’s easier for humans to read and perceive.\nProvides DataFrame and Series data structures"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#whats-pandas",
    "href": "for-tas/03-pandas-notes.html#whats-pandas",
    "title": "Dataframe with Pandas",
    "section": "",
    "text": "pandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language. 1 pandas aims to be the fundamental high-level building block for doing practical, real world data analysis in Python.\n\n\nWell-established Python library for data manipulation and analysis\nBuilt on top of NumPy. Unlike Numpy who can be difficult to “read”, Dataframe presents data in tabular format that’s easier for humans to read and perceive.\nProvides DataFrame and Series data structures"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#comparison-to-numpy",
    "href": "for-tas/03-pandas-notes.html#comparison-to-numpy",
    "title": "Dataframe with Pandas",
    "section": "Comparison to Numpy",
    "text": "Comparison to Numpy\n\n\n\n\n\n\n\n\nFeature\nNumPy Array\npandas DataFrame\n\n\n\n\nData Types\nAll elements must be of the same type (e.g., integers, floats).\nDifferent columns can hold different data types (e.g., integers, floats, strings).\n\n\nPerformance\nFaster for numerical computations due to homogeneity and optimized implementation.\nSlightly slower but more flexible for working with heterogeneous or labeled data.\n\n\nDimensionality\nCan be multi-dimensional (1D, 2D, 3D, etc.).\nAlways two-dimensional with labeled rows and columns.\n\n\nIndexing\nPurely positional indexing (e.g., array[0, 1]).\nLabeled-based indexing (loc), position-based indexing (iloc), access by both labels and positions.\n\n\nUsage\nPrimarily for high-performance numerical and scientific computations.\nPrimarily for data manipulation, analysis, and cleaning, especially for tabular and real-world datasets."
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#installing-and-importing-packages",
    "href": "for-tas/03-pandas-notes.html#installing-and-importing-packages",
    "title": "Dataframe with Pandas",
    "section": "Installing and importing packages",
    "text": "Installing and importing packages\nTo install this package, you can use this command:\npip install pandas\npip install seaborn\nRemember, we must first import these packages to our notebook / script before we can use them.\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n\n\n\n\nPandas Cheatsheet\n\n\n\nHave this cheatsheet open on another tab as you work through your data: https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#load-data-from-csv-to-dataframe",
    "href": "for-tas/03-pandas-notes.html#load-data-from-csv-to-dataframe",
    "title": "Dataframe with Pandas",
    "section": "Load data from CSV to DataFrame",
    "text": "Load data from CSV to DataFrame\n\n\n\n\n\n\nBefore we begin…\n\n\n\nRight-click here to open unemployment-age.csv, and then Ctrl + S / Cmd + S to save it locally into your data folder\n\n\nTypically, we load the data from API source (more on this next week!) or external data file such as CSV. Let’s load the unemployment-age.csv now!\nunemp_data = pd.read_csv('data/unemployment-age.csv')\nprint(unemp_data.head())"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#initial-checks-get-basic-info",
    "href": "for-tas/03-pandas-notes.html#initial-checks-get-basic-info",
    "title": "Dataframe with Pandas",
    "section": "Initial checks: get basic info",
    "text": "Initial checks: get basic info\nThe first thing that you should always do is check on the dataframe to get an overview of it. The function info() will tell us the data types for each columns, the number of observations, and index info if there’s any.\nunemp_data.info()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#initial-checks-get-summary-stats",
    "href": "for-tas/03-pandas-notes.html#initial-checks-get-summary-stats",
    "title": "Dataframe with Pandas",
    "section": "Initial checks: get summary stats",
    "text": "Initial checks: get summary stats\nAlso get the summary statistics to get a sense of the shape and spread of your data.\nunemp_data.describe()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#initial-checks-column-names",
    "href": "for-tas/03-pandas-notes.html#initial-checks-column-names",
    "title": "Dataframe with Pandas",
    "section": "Initial checks: column names",
    "text": "Initial checks: column names\nOptional, but you may also want to check on the column names to see how it appears in our environment (useful if you happen to have non UTF-8 characters as your column names)\nprint(unemp_data.columns)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#dropping-columns",
    "href": "for-tas/03-pandas-notes.html#dropping-columns",
    "title": "Dataframe with Pandas",
    "section": "Dropping columns",
    "text": "Dropping columns\nIn some cases, we don’t really need the entire columns. Let’s drop the last column (that looks like an error in the CSV formatting).\nunemp_data.drop(unemp_data.columns[-1], axis = 1, inplace= True)\nunemp_data.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#renaming-columns",
    "href": "for-tas/03-pandas-notes.html#renaming-columns",
    "title": "Dataframe with Pandas",
    "section": "Renaming columns",
    "text": "Renaming columns\nSometimes the column names are not ideal. In our case, let’s give a name to each age group!\nunemp_data.columns = ['date', 'teenagers', 'young_adults', 'adults', 'seniors']\nprint(unemp_data.columns)\nAlternatively, if you just want to rename specific columns:\nunemp_data.rename(columns={'16_19yrs': 'teenagers', '20_24yrs': 'young_adults'}, inplace = True)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#data-wrangling-with-pandas-and-seaborn---scenarios",
    "href": "for-tas/03-pandas-notes.html#data-wrangling-with-pandas-and-seaborn---scenarios",
    "title": "Dataframe with Pandas",
    "section": "Data Wrangling with Pandas and Seaborn - Scenarios",
    "text": "Data Wrangling with Pandas and Seaborn - Scenarios\nLet’s see if we can complete the following tasks:\n\nRemove all the missing values\nWe are primarily interested in the young adult unemployment. Separate this data into a new dataframe called ya_unemp\nRetrieve the months and years where the young adult rate is more than 10 percent and keep this on high_ya_unemp\nAdd in a new column that tracks the total unemployment rate for each month\nCreate a Quarterly dataset from the current dataframe that captures the mean unemployment rate\nCalculate the year-on-year change of unemployment rate\nVisualize the dataset"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-1---handling-missing-values",
    "href": "for-tas/03-pandas-notes.html#task-1---handling-missing-values",
    "title": "Dataframe with Pandas",
    "section": "Task 1 - Handling missing values",
    "text": "Task 1 - Handling missing values\nOther than info(), we can also use isnull() to check for null values\n# Check for missing values\nprint(unemp_data.isnull().sum())"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#handling-missing-values-drop-or-no-drop",
    "href": "for-tas/03-pandas-notes.html#handling-missing-values-drop-or-no-drop",
    "title": "Dataframe with Pandas",
    "section": "Handling missing values: drop or no drop?",
    "text": "Handling missing values: drop or no drop?\nWe can drop those rows that contains null values with dropna()…\n# Drop rows with missing values (if any)\nunemp_data = unemp_data.dropna()\nprint(unemp_data.info())\n… or we can also fill in the null values with something else, e.g. 0\nuemp_data = unemp_data.fillna(0)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-2---retrieving-columns-a-single-column",
    "href": "for-tas/03-pandas-notes.html#task-2---retrieving-columns-a-single-column",
    "title": "Dataframe with Pandas",
    "section": "Task 2 - Retrieving columns: a single column",
    "text": "Task 2 - Retrieving columns: a single column\nAs the column names in DataFrame are indexed, we can simply call them by their column names! (Much more intuitive compared to Numpy)\nya_unemp = unemp_data['young_adults']\nya_unemp.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#retrieving-columns-multiple-columns",
    "href": "for-tas/03-pandas-notes.html#retrieving-columns-multiple-columns",
    "title": "Dataframe with Pandas",
    "section": "Retrieving columns: multiple columns",
    "text": "Retrieving columns: multiple columns\nSimilarly, if we want to retrieve multiple columns, we can pass a list of column names to the dataframe and save these sliced columns into a new dataframe.\nya_unemp = unemp_data[['date', 'young_adults']]\nya_unemp.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-3---filtering-rows-without-query",
    "href": "for-tas/03-pandas-notes.html#task-3---filtering-rows-without-query",
    "title": "Dataframe with Pandas",
    "section": "Task 3 - Filtering row(s): without query()",
    "text": "Task 3 - Filtering row(s): without query()\nWe can do it “raw” or us the query function from pandas. Here is how you can do it without the query() function:\ncriteria = unemp_data[\"young_adults\"] &gt; 10\nhigh_ya_unemp = unemp_data[criteria]\nhigh_ya_unemp.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#filtering-rows-with-query",
    "href": "for-tas/03-pandas-notes.html#filtering-rows-with-query",
    "title": "Dataframe with Pandas",
    "section": "Filtering row(s): with query()",
    "text": "Filtering row(s): with query()\nAnd here is how you can do it with the query() function:\nprint(unemp_data.query('young_adults &gt; 10'))"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#filtering-rows-with-query-and-save-result",
    "href": "for-tas/03-pandas-notes.html#filtering-rows-with-query-and-save-result",
    "title": "Dataframe with Pandas",
    "section": "Filtering row(s): with query() and save result",
    "text": "Filtering row(s): with query() and save result\nTake note that the previous code will simply print out the result! If you want to save the result, make sure to assign the result to a new dataframe.\nhigh_ya_unemp = unemp_data.query('young_adults &gt; 10')\nhigh_ya_unemp.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-4---adding-new-columns",
    "href": "for-tas/03-pandas-notes.html#task-4---adding-new-columns",
    "title": "Dataframe with Pandas",
    "section": "Task 4 - Adding new column(s)",
    "text": "Task 4 - Adding new column(s)\nLet’s add a new column for total unemployment (sum of all age groups)\nunemp_data['total_unemployment'] = unemp_data['teenagers'] + unemp_data['young_adults'] + unemp_data['adults'] + unemp_data['seniors']\nunemp_data.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#side-quest-datetime-object",
    "href": "for-tas/03-pandas-notes.html#side-quest-datetime-object",
    "title": "Dataframe with Pandas",
    "section": "Side quest: DateTime Object",
    "text": "Side quest: DateTime Object\n\nA DateTime object in Python, provided by the datetime module, represents a specific point in time, including the year, month, day, hour, minute, second, and microsecond.\nIt can be used to manipulate dates and times, perform arithmetic on dates, and format dates into other string representation e.g. from dd/mm/yyyy to yyyy-mm-dd.\n\nfrom datetime import datetime\n\nnow = datetime.now()\nprint(\"Current Date and Time:\", now)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#components-of-datetime",
    "href": "for-tas/03-pandas-notes.html#components-of-datetime",
    "title": "Dataframe with Pandas",
    "section": "Components of DateTime",
    "text": "Components of DateTime\nThe DateTime object consists of multiple components that represent different parts of the date and time, such as year, month, day, hour, minute, second, etc. You can access these components individually.\n# Extract year, month, and day from a specific date\nnow = datetime.now()\n\n# Access individual components\nprint(\"Year:\", now.year)\nprint(\"Month:\", now.month)\nprint(\"Day:\", now.day)\nprint(\"Hour:\", now.hour)\nprint(\"Minute:\", now.minute)\nprint(\"Second:\", now.second)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#datetime-operations",
    "href": "for-tas/03-pandas-notes.html#datetime-operations",
    "title": "Dataframe with Pandas",
    "section": "DateTime operations",
    "text": "DateTime operations\n\nYou can perform various operations with DateTime objects, such as calculating the difference between two dates or adding/subtracting time with the help of timedelta.\nThese are essential for time series data manipulation, where date-based arithmetic is often required.\n\nfrom datetime import timedelta\n\nnow = datetime.now()\n\nlast_week = now - timedelta(days=7)\nprint(\"1 week ago:\", last_week)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#back-to-main-quest-time-series-with-dataframe",
    "href": "for-tas/03-pandas-notes.html#back-to-main-quest-time-series-with-dataframe",
    "title": "Dataframe with Pandas",
    "section": "Back to Main Quest: Time Series with DataFrame",
    "text": "Back to Main Quest: Time Series with DataFrame\nLet’s index the rows under date column as a DateTime index.\n1unemp_data['date'] = pd.to_datetime(unemp_data['date'], format=\"%Y-%m-%d\")\n2unemp_data.set_index('date', inplace=True)\n\n1\n\nConvert the data type under date column from string to DateTime object\n\n2\n\nSet the date column as the index.\n\n\n\n\nYou can refer to this page to see how to format the string expression of DateTime object: https://www.w3schools.com/python/python_datetime.asp"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#datetime-is-the-index-now-what",
    "href": "for-tas/03-pandas-notes.html#datetime-is-the-index-now-what",
    "title": "Dataframe with Pandas",
    "section": "DateTime is the index, now what?",
    "text": "DateTime is the index, now what?\nLet’s check on the dataframe once more, to make sure that it is indexed as intended:\nunemp_data.info()\nIf all goes well, the date column should be part of the index now."
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#extra-checks-with-time-series",
    "href": "for-tas/03-pandas-notes.html#extra-checks-with-time-series",
    "title": "Dataframe with Pandas",
    "section": "Extra checks with Time Series",
    "text": "Extra checks with Time Series\nOther things that we may want to check with Time Series is the date range of our data.\nprint(\"start date\", unemp_data.index.min())\nprint(\"end date\", unemp_data.index.max())\nprint(\"length\", unemp_data.index.max() - unemp_data.index.min())"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#retrieve-specific-date-range",
    "href": "for-tas/03-pandas-notes.html#retrieve-specific-date-range",
    "title": "Dataframe with Pandas",
    "section": "Retrieve specific date range",
    "text": "Retrieve specific date range\nNow that the index is a DateTime object, we can easily retrieve specific date range! Let’s say we would like retrieve unemployment rate for during COVID, which will be March 2020 to May 2023.\nunemp_data_covid = unemp_data.loc['2020-03':'2023-05']\nunemp_data_covid.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#capture-the-month-info-into-a-separate-column",
    "href": "for-tas/03-pandas-notes.html#capture-the-month-info-into-a-separate-column",
    "title": "Dataframe with Pandas",
    "section": "Capture the month info into a separate column",
    "text": "Capture the month info into a separate column\nWith DateTime object as the index, we can easily capture the month info. This would be useful to see whether certain months tend to have higher unemployment rate based on this data.\nunemp_data['month'] = unemp_data.index.month\nunemp_data.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#aggregate-statistics",
    "href": "for-tas/03-pandas-notes.html#aggregate-statistics",
    "title": "Dataframe with Pandas",
    "section": "Aggregate statistics",
    "text": "Aggregate statistics\nLet’s calculate the average unemployment rate for each month based on this data.\nunemp_permonth = unemp_data.groupby('month').mean()\nprint(unemp_permonth)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-5---resampling-to-quarterly-data",
    "href": "for-tas/03-pandas-notes.html#task-5---resampling-to-quarterly-data",
    "title": "Dataframe with Pandas",
    "section": "Task 5 - Resampling to Quarterly data",
    "text": "Task 5 - Resampling to Quarterly data\nWith time series, we can calculate the quarterly average based on the monthly data with resample()\nquarterly_data = unemp_data.resample('Q').mean()\nquarterly_data.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#resampling-to-yearly-data",
    "href": "for-tas/03-pandas-notes.html#resampling-to-yearly-data",
    "title": "Dataframe with Pandas",
    "section": "Resampling to Yearly data",
    "text": "Resampling to Yearly data\nLet’s find out what is the highest unemployment rate for each year!\nyearly_data = unemp_data.resample('Y').max()\nyearly_data.head()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#saving-into-a-csv",
    "href": "for-tas/03-pandas-notes.html#saving-into-a-csv",
    "title": "Dataframe with Pandas",
    "section": "Saving into a CSV",
    "text": "Saving into a CSV\nLet’s save the quarterly data to a CSV!\nquarterly_data.to_csv(\"data-output/yearly-unemployment-age.csv\")"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#changing-the-frequency-of-time-series",
    "href": "for-tas/03-pandas-notes.html#changing-the-frequency-of-time-series",
    "title": "Dataframe with Pandas",
    "section": "Changing the frequency of Time Series",
    "text": "Changing the frequency of Time Series\nLet’s say we would like get a weekly time series. Since our data is a monthly one, there will be rows with empty values if we change the frequency. There are several methods that we can employ here to fill this empty values:\n\nbackfill\nforward fill\ninterpolate\n\nunemp_data_weekly = unemp_data.resample('1W').ffill()\nunemp_data_weekly.tail()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#task-7---visualize-time-series",
    "href": "for-tas/03-pandas-notes.html#task-7---visualize-time-series",
    "title": "Dataframe with Pandas",
    "section": "Task 7 - Visualize Time Series",
    "text": "Task 7 - Visualize Time Series\nLet’s plot the entire\nunemp_data.plot()\nplt.title('Unemployment Rate for Young Adults')\nplt.ylabel('Unemployment Rate (%)')\nplt.show()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#calculate-the-changes-for-each-month",
    "href": "for-tas/03-pandas-notes.html#calculate-the-changes-for-each-month",
    "title": "Dataframe with Pandas",
    "section": "Calculate the changes for each month",
    "text": "Calculate the changes for each month\nTo capture the direction and magnitude of changes in unemployment rate each month, use diff() function!\nunemp_data['changes_ya'] = unemp_data['young_adults'].diff()\nunemp_data['changes_ya'].head(7)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#calculate-yeor-on-year-changes-for-young-adults",
    "href": "for-tas/03-pandas-notes.html#calculate-yeor-on-year-changes-for-young-adults",
    "title": "Dataframe with Pandas",
    "section": "Calculate yeor-on-year changes for young adults",
    "text": "Calculate yeor-on-year changes for young adults\nLet’s get the year-on-year change!\nunemp_data['ya_YoY_pctchange'] = unemp_data['young_adults'].pct_change(periods=12) # multiply by 100 to get the %\nunemp_data.tail()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#visualize-the-changes",
    "href": "for-tas/03-pandas-notes.html#visualize-the-changes",
    "title": "Dataframe with Pandas",
    "section": "Visualize the changes",
    "text": "Visualize the changes\nLet’s quickly visualize the changes:\nunemp_data['changes_ya'].plot()"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#more-seaborn-scatterplot",
    "href": "for-tas/03-pandas-notes.html#more-seaborn-scatterplot",
    "title": "Dataframe with Pandas",
    "section": "More Seaborn: Scatterplot",
    "text": "More Seaborn: Scatterplot\nSeaborn can do many other visualizations as well. For example, let’s try plotting a scatterplot of ‘young_adults’ and ‘seniors’\nsns.scatterplot(x = 'young_adults', y = 'seniors', data = unemp_data)"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#more-seaborn-boxplot",
    "href": "for-tas/03-pandas-notes.html#more-seaborn-boxplot",
    "title": "Dataframe with Pandas",
    "section": "More Seaborn: Boxplot",
    "text": "More Seaborn: Boxplot\nLet’s see how unemployment rate fared each month for young_adults. Are there any outliers?\nsns.boxplot(x = 'month', y = 'young_adults', data=unemp_data[['month', 'young_adults']])"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#more-seaborn-barplot",
    "href": "for-tas/03-pandas-notes.html#more-seaborn-barplot",
    "title": "Dataframe with Pandas",
    "section": "More Seaborn: Barplot",
    "text": "More Seaborn: Barplot\nWhich month seems to have the highest unemployment rate on average?\nsns.barplot(data = unemp_permonth, x = unemp_permonth.index, y = 'young_adults')"
  },
  {
    "objectID": "for-tas/03-pandas-notes.html#footnotes",
    "href": "for-tas/03-pandas-notes.html#footnotes",
    "title": "Dataframe with Pandas",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://pandas.pydata.org/↩︎"
  },
  {
    "objectID": "for-tas/01-basics-notes.html",
    "href": "for-tas/01-basics-notes.html",
    "title": "Introduction to Python",
    "section": "",
    "text": "print(\"Hello World!\")\n5 + 5 \nPython has a built-in function called print that prints things as text.\nCall the function (i.e., tell Python to run it) by using its name.\nprint(10 - 5)\nprint(10 * 2)\nprint(\"hello world\")\nUse comments to add a layer of documentation to your code. E.g., explain what a block of code does, etc."
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-1-getting-started",
    "href": "for-tas/01-basics-notes.html#section-1-getting-started",
    "title": "Introduction to Python",
    "section": "",
    "text": "print(\"Hello World!\")\n5 + 5 \nPython has a built-in function called print that prints things as text.\nCall the function (i.e., tell Python to run it) by using its name.\nprint(10 - 5)\nprint(10 * 2)\nprint(\"hello world\")\nUse comments to add a layer of documentation to your code. E.g., explain what a block of code does, etc."
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-2-variables-and-assignment",
    "href": "for-tas/01-basics-notes.html#section-2-variables-and-assignment",
    "title": "Introduction to Python",
    "section": "Section 2: Variables and Assignment",
    "text": "Section 2: Variables and Assignment\n\nHow can I store data and perform simple calculations?\nVariables are names for values. # In Python, the = symbol assigns the value on the right to the variable on the left. # Once you declare a variable, you must assign value to it\ngreetings = \"Hello World!\"\nage = 25\nname  # This cell will give you an error because you tried to declare a variable without assigning a value to it. \nVariable names: don’t start with a digit, alphanumeric only with underscore, case sensitive, should be meaningful\nYou can also use print() to print out a variable’s value\nPut the variable name inside the bracket.\nThe things we passed to the function (the things inside the brackets) are called ‘arguments’ (more on this later)\nprint(greetings)\nprint(\"today's greetings:\", greetings)\nVariables must be created before they are used.\nIf a variable doesn’t exist yet, or if the name has been mis-spelled, Python reports an error.\nVariables can be used in calculations! We can use variables in calculations just as if they were values.\nage = age + 10\nprint(\"Age in ten years from now:\", age)\nYou can also assign a variable value to another variable\ncontinent = \"Asia\"\nposition = continent  # assign \"sign\" value to direction\nprint(position, continent)  # now both direction and sign has the same value!"
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-3-data-types-and-conversion",
    "href": "for-tas/01-basics-notes.html#section-3-data-types-and-conversion",
    "title": "Introduction to Python",
    "section": "Section 3: Data Types and Conversion",
    "text": "Section 3: Data Types and Conversion\ncountry = \"Singapore\"  # string\npublic_holidays = 11  # integer\navg_temp = 27.8  # float\npart_of_asean = True  # Boolean\nUse the built-in function type to find out what type a value or a variable has.\nRemember, when you change the value of a variable to a new data type,\nthe results of print(type(your_variable)) will change accordingly.\nQuestion: What is the type of part_of_asean?\nprint(type(part_of_asean))  # this should print out Boolean\nWhat would happen if we do this?\npart_of_asean = \"True\"\nprint(type(part_of_asean))  # now this should be a string!\nWhy care about data type?\nBecause a value’s data type determines what the program can do to it.\nThe calculations below work on int data type\nprint(public_holidays - 5)  \nBut this won’t work on a string\nprint(country - \"pore\") \nHowever you can use “+” and “*” on strings\nprint(country + \" best\")  # this works for string, though.\nprint(country * 4)  # this also works\nprint(\"=\" * 10)  # this also works\nprint(len(country))  # this would print out the number of characters a string has\nlen(public_holidays) \\# this should give you an error\nSome data types need to be converted before we can do some operations on them i.e. this will give you an error.\nprint(\"10\" + 2) \nprint(\"10\" + str(2))  # either we convert them all to string\nprint(int(10) + 2)  # or we convert them to int\nTake note of the execution order of your variables! They only change value when something is assigned to them.\npublic_holiday = 11  # initial value \nnew_holidays = public_holiday + 5\npublic_holiday = 10  # we update the variable\nprint(public_holiday, new_holidays)"
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-4-built-in-functions-help-and-error-messages",
    "href": "for-tas/01-basics-notes.html#section-4-built-in-functions-help-and-error-messages",
    "title": "Introduction to Python",
    "section": "Section 4: Built-in functions, Help, and Error Messages",
    "text": "Section 4: Built-in functions, Help, and Error Messages\n\nExplain how to pull the help function\nSome tips on error messages\nRefer to slides for full content"
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-5-list",
    "href": "for-tas/01-basics-notes.html#section-5-list",
    "title": "Introduction to Python",
    "section": "Section 5: List",
    "text": "Section 5: List\nquarterly_gdp_growth = [-2,-5.8, 2.8, 2.6, 7.3, 7.8]  # growth rates from 2023 Q1 to 2024 Q2\nprint('GDP growth rates:', quarterly_gdp_growth)\nprint('Number of quarters:', len(quarterly_gdp_growth))\nUse square bracket and index number to retrieve an item from the list.\nRemember that index starts from 0 instead of 1.\nSo if you want to retrieve the fourth item (2021’s growth rate), the index will be 3.\nprint('GDP growth rate in 2023 Q1:', quarterly_gdp_growth[0])\nprint('GDP growth rate in 2024 Q2:', quarterly_gdp_growth[5])\nList values can be replaced by simply assigning a new value to them.\nUpdate the growth rate for 2023 Q3 (index 2) with the correct figure.\nquarterly_gdp_growth[2] = -2.8\nprint('Updated GDP growth rates:', quarterly_gdp_growth)\nWhat happens if we try to retrieve an index that doesn’t exist?\nquarterly_gdp_growth[10] # This would cause an IndexError\nYou can append to the list (e.g., if we get data for 2024 Q3)\nprint('GDP growth rates initially:', quarterly_gdp_growth)\nquarterly_gdp_growth.append(3.2)  # Adding hypothetical  data\nprint('GDP growth rates after adding 2024 Q3 prediction:', quarterly_gdp_growth)\nadding item at the start e.g. 2022 Q4 was 9.4\nprint('GDP growth rates initially:', quarterly_gdp_growth)\nquarterly_gdp_growth.insert(0, 9.4) \nprint('GDP growth rates after adding 2022 Q4:', quarterly_gdp_growth)\nremove the two items we added\nprint('GDP growth rates initially:', quarterly_gdp_growth)\ndel quarterly_gdp_growth[0]  \nquarterly_gdp_growth.pop()\nprint('GDP growth rates after removing projection:', quarterly_gdp_growth)\nslicing list\nprint('Quarterly GDP growth rates in 2023:', quarterly_gdp_growth[0:4])  # Remember, the end index is exclusive\nprint('Most recent growth rate:', quarterly_gdp_growth[-1])  # Get the last item in the list\nprint('Growth rates for even quarters:', quarterly_gdp_growth[::2])  # Every other item\n# remember: list[start:end:stride]\nYou can also initialize an empty list to fill later\nfuture_growth_rates = []\nPrint the average quarterly GDP growth rate\ntotal_growth = sum(quarterly_gdp_growth)\naverage_growth = total_growth / len(quarterly_gdp_growth)\nprint(f\"Average quarterly GDP growth: {average_growth:.2f}%\")\nYou can include values of different types in a list, though for GDP data we’ll stick to numbers\nmixed_data = [\"2024 growth\", 3.0, \"2023 growth\", 2.7]\nprint(mixed_data)\n\nLearning Check #3\nWrite a code to print the growth rate for 2023 Q4 (remember, it’s the 5th item but index 4)\nprint(quarterly_gdp_growth[4])\nWrite a code to print the growth rates for the first three quarters of 2023\nprint(quarterly_gdp_growth[0:3])\nAdd a projected growth rate of 3.3 and 3.6 for 2024 Q3 and Q4 respectively at the end of the list\nquarterly_gdp_growth.insert(len(quarterly_gdp_growth), 3.3)\nquarterly_gdp_growth.insert(len(quarterly_gdp_growth), 3.6)\nprint(quarterly_gdp_growth)"
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-6-for-loops",
    "href": "for-tas/01-basics-notes.html#section-6-for-loops",
    "title": "Introduction to Python",
    "section": "Section 6: For Loops",
    "text": "Section 6: For Loops\nBasic loop example\nfor number in range(1, 7):  # 1 to 6, representing 6 quarters\n    print(\"Quarter\", number)\nYou can also use list in a for loop!\nA for loop executes commands once for each value in a list/collection.\nIt is basically telling python: “for each item in this list/collection, do these operations”\nfor growth in quarterly_gdp_growth:\n    print(f\"Quarterly GDP growth: {growth}%\")\nLet’s create a more informative output by combining the quarter information with the growth rate\nquarters = [\"2023 Q1\", \"2023 Q2\", \"2023 Q3\", \"2023 Q4\", \"2024 Q1\", \"2024 Q2\", \"2024 Q3 prediction\", \"2024 Q4 prediction\"]\nlen(quarterly_gdp_growth)\nfor i in range(len(quarterly_gdp_growth)-1):\n    print(f\"{quarters[i]}: {quarterly_gdp_growth[i]}% GDP growth\")\nPrint out only the quarters with GDP growth rate above 1%\nprint(quarterly_gdp_growth)\nfor i, growth in enumerate(quarterly_gdp_growth):\n    if growth &gt; 1:\n        print(i, growth)\n        print(f\"{quarters[i]} had positive growth: {growth}%\")"
  },
  {
    "objectID": "for-tas/01-basics-notes.html#section-7-conditionals-if-else",
    "href": "for-tas/01-basics-notes.html#section-7-conditionals-if-else",
    "title": "Introduction to Python",
    "section": "Section 7: Conditionals (If-Else)",
    "text": "Section 7: Conditionals (If-Else)\nLet’s categorize our GDP growth rates\nlatest_growth = quarterly_gdp_growth[-1]  # Get the most recent growth rate\nif latest_growth &gt; 1:\n    print(f\"The latest GDP growth of {latest_growth}% indicates strong economic expansion.\")\nelif latest_growth &gt; 0:\n    print(f\"The latest GDP growth of {latest_growth}% shows moderate economic growth.\")\nelse:\n    print(f\"The latest GDP growth of {latest_growth}% suggests economic contraction.\")\nConditionals are often used inside loops.\nLet’s categorize all our quarterly growth rates.\nfor i, growth in enumerate(quarterly_gdp_growth):\n    if growth &gt; 1:\n        print(f\"{quarters[i]}: Strong growth at {growth}%\")\n    elif growth &gt; 0.5:\n        print(f\"{quarters[i]}: Moderate growth at {growth}%\")\n    else:\n        print(f\"{quarters[i]}: Slow growth at {growth}%\")\nYou can add a catch-all statement, else in conditionals.\nThe code inside this catch-all will be executed if none of the conditions are satisfied.\nLet’s check if we’ve had any quarters with negative growth\nfor i, growth in enumerate(quarterly_gdp_growth):\n    if growth &lt; 0:\n        print(f\"{quarters[i]} showed economic contraction with {growth}% growth.\")\n        break  # Exit the loop if we find a negative growth quarter\n    else:\n        print(\"No quarters showed economic contraction in this period.\")\nWhat if you have more than one condition?\nUse elif (short for “else if”) to specify additional tests.\nelif must be placed between if and `else\nLet’s categorize growth rates more precisely\nfor i, growth in enumerate(quarterly_gdp_growth):\n    if growth &gt; 10:\n        print(f\"{quarters[i]}: Very strong growth at {growth}%\")\n    elif growth &gt; 5:\n        print(f\"{quarters[i]}: Strong growth at {growth}%\")\n    elif growth &gt; 2:\n        print(f\"{quarters[i]}: Moderate growth at {growth}%\")\n    elif growth &gt; 0:\n        print(f\"{quarters[i]}: Slow growth at {growth}%\")\n    else:\n        print(f\"{quarters[i]}: Economic contraction at {growth}%\")\nIMPORTANT\nPython steps through the statements of the conditional in order,\ntesting each in turn. So ordering matters!\nLet’s see an example of why order matters:\nfor growth in quarterly_gdp_growth:\n    if growth &gt; 0:\n        print(f\"{growth}% is moderate growth\")\n    elif growth &gt; 5:  # This will never be reached for growth &gt; 1\n        print(f\"{growth}% is strong growth\")\n    else:\n        print(f\"{growth}% is negative growth\")\nThe correct order would be:\nfor growth in quarterly_gdp_growth:\n    if growth &gt; 5:\n        print(f\"{growth}% is strong growth\")\n    elif growth &gt; 0:\n        print(f\"{growth}% is moderate growth\")\n    else:\n        print(f\"{growth}% is negative growth\")\n\nLearning check #4: Analyze GDP growth trends\nWrite a script that identifies the highest and lowest growth quarters\nhighest_growth = max(quarterly_gdp_growth)\nlowest_growth = min(quarterly_gdp_growth)\n\nhighest_quarter = quarters[quarterly_gdp_growth.index(highest_growth)]\nlowest_quarter = quarters[quarterly_gdp_growth.index(lowest_growth)]\n\nprint(f\"Highest growth: {highest_growth}% in {highest_quarter}\")\nprint(f\"Lowest growth: {lowest_growth}% in {lowest_quarter}\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About the Workshop",
    "section": "",
    "text": "The workshop is jointly organised by SEIC and DSA student clubs from SMU, in collaboration with SMU Libraries. The workshop aims to:\n\nIncrease students’ efficiency in the collection, analysis, and visualisation of data with Python.\nHelp SEIC students to be industry-ready as the banking and finance, macroeconomic research, and public sectors are increasingly demanding the use of Python.\nExpose DSA students to how Python can be integrated with macroeconomic research."
  },
  {
    "objectID": "03-pandas.html#recap-from-yesterday",
    "href": "03-pandas.html#recap-from-yesterday",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Recap from yesterday",
    "text": "Recap from yesterday\n\nPython libraries / packages\nIntroduction to Numpy (+ numpy-financial)\nGetting started with visualizations with matplotlib"
  },
  {
    "objectID": "03-pandas.html#overview-for-today",
    "href": "03-pandas.html#overview-for-today",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Overview for today",
    "text": "Overview for today\nToday, we will cover the typical steps when doing data analysis projects. For this session, we will do simple time series analysis.\n\nStep 1: Loading and pre-processing data (with pandas)\nStep 2: Time Series analysis\nStep 3: Data Visualization (with Seaborn)"
  },
  {
    "objectID": "03-pandas.html#whats-pandas",
    "href": "03-pandas.html#whats-pandas",
    "title": "Introduction to Pandas and Seaborn",
    "section": "What’s Pandas?",
    "text": "What’s Pandas?\n\n\n\n\n\npandas is a fast, powerful, flexible and easy to use open source data analysis and manipulation tool, built on top of the Python programming language. pandas aims to be the fundamental high-level building block for doing practical, real world data analysis in Python. 1\n\n\nWell-established Python library for data manipulation and analysis\nBuilt on top of NumPy. Unlike Numpy who can be difficult to “read”, Dataframe presents data in tabular format that’s easier for humans to read and perceive.\nProvides DataFrame and Series data structures\nMany cheatsheets available: https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf or https://python-graph-gallery.com/cheat-sheets/\n\n\nhttps://pandas.pydata.org/"
  },
  {
    "objectID": "03-pandas.html#comparison-to-numpy",
    "href": "03-pandas.html#comparison-to-numpy",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Comparison to Numpy",
    "text": "Comparison to Numpy\n\n\n\n\n\n\n\n\nFeature\nNumPy Array\npandas DataFrame\n\n\n\n\nData Types\nAll elements must be of the same type (e.g., integers, floats).\nDifferent columns can hold different data types (e.g., integers, floats, strings).\n\n\nPerformance\nFaster for numerical computations due to homogeneity and optimized implementation.\nSlightly slower but more flexible for working with heterogeneous or labeled data.\n\n\nDimensionality\nCan be multi-dimensional (1D, 2D, 3D, etc.).\nAlways two-dimensional with labeled rows and columns.\n\n\nIndexing\nPurely positional indexing (e.g., array[0, 1]).\nLabeled-based indexing (loc), position-based indexing (iloc), access by both labels and positions.\n\n\nUsage\nPrimarily for high-performance numerical and scientific computations.\nPrimarily for data manipulation, analysis, and cleaning, especially for tabular and real-world datasets."
  },
  {
    "objectID": "03-pandas.html#installing-and-importing-packages",
    "href": "03-pandas.html#installing-and-importing-packages",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Installing and importing packages",
    "text": "Installing and importing packages\nTo install this package, you can use this command:\npip install pandas\npip install seaborn\nRemember, we must first import these packages to our notebook / script before we can use them.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n\n\n\n\n\n\nPandas Cheatsheet\n\n\nHave this cheatsheet open on another tab as you work through your data: https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf or https://python-graph-gallery.com/cheat-sheets/"
  },
  {
    "objectID": "03-pandas.html#load-data-from-csv-to-dataframe",
    "href": "03-pandas.html#load-data-from-csv-to-dataframe",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Load data from CSV to DataFrame",
    "text": "Load data from CSV to DataFrame\n\n\n\n\n\n\n\nBefore we begin…\n\n\nRight-click here to open unemployment-age.csv, and then Ctrl + S / Cmd + S to save it locally into your data folder\n\n\n\n\nTypically, we load the data from API source (more on this next week!) or external data file such as CSV. Let’s load the unemployment-age.csv now!\n\nunemp_data = pd.read_csv('data/unemployment-age.csv')\nprint(unemp_data.head())\n\n         date  16_19yrs  20_24yrs  25_54yrs  55yrs_onwards  Unnamed: 5\n0  1948-01-01      10.1       6.6       3.0            3.6         NaN\n1  1948-02-01      11.5       8.0       3.6            4.0         NaN\n2  1948-03-01      10.8       8.6       3.2            3.5         NaN\n3  1948-04-01       8.8       6.8       3.2            3.2         NaN\n4  1948-05-01       6.9       6.3       2.6            2.9         NaN"
  },
  {
    "objectID": "03-pandas.html#initial-checks-get-basic-info",
    "href": "03-pandas.html#initial-checks-get-basic-info",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Initial checks: get basic info",
    "text": "Initial checks: get basic info\nThe first thing that you should always do is check on the dataframe to get an overview of it. The function info() will tell us the data types for each columns, the number of observations, and index info if there’s any.\n\nunemp_data.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 920 entries, 0 to 919\nData columns (total 6 columns):\n #   Column         Non-Null Count  Dtype  \n---  ------         --------------  -----  \n 0   date           920 non-null    object \n 1   16_19yrs       920 non-null    float64\n 2   20_24yrs       920 non-null    float64\n 3   25_54yrs       920 non-null    float64\n 4   55yrs_onwards  920 non-null    float64\n 5   Unnamed: 5     0 non-null      float64\ndtypes: float64(5), object(1)\nmemory usage: 43.3+ KB"
  },
  {
    "objectID": "03-pandas.html#initial-checks-get-summary-stats",
    "href": "03-pandas.html#initial-checks-get-summary-stats",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Initial checks: get summary stats",
    "text": "Initial checks: get summary stats\nAlso get the summary statistics to get a sense of the shape and spread of your data.\n\nunemp_data.describe()\n\n\n\n\n\n\n\n\n16_19yrs\n20_24yrs\n25_54yrs\n55yrs_onwards\nUnnamed: 5\n\n\n\n\ncount\n920.000000\n920.000000\n920.000000\n920.00000\n0.0\n\n\nmean\n15.913370\n9.259674\n4.560109\n3.79837\nNaN\n\n\nstd\n4.270376\n2.790013\n1.585635\n1.23832\nNaN\n\n\nmin\n5.700000\n3.300000\n1.800000\n1.50000\nNaN\n\n\n25%\n13.000000\n7.575000\n3.400000\n2.90000\nNaN\n\n\n50%\n15.600000\n8.900000\n4.300000\n3.50000\nNaN\n\n\n75%\n18.400000\n10.700000\n5.500000\n4.40000\nNaN\n\n\nmax\n32.200000\n25.000000\n12.600000\n13.40000\nNaN"
  },
  {
    "objectID": "03-pandas.html#initial-checks-column-names",
    "href": "03-pandas.html#initial-checks-column-names",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Initial checks: column names",
    "text": "Initial checks: column names\nOptional, but you may also want to check on the column names to see how it appears in our environment (useful if you happen to have non UTF-8 characters as your column names)\n\nprint(unemp_data.columns)\n\nIndex(['date', '16_19yrs', '20_24yrs', '25_54yrs', '55yrs_onwards',\n       'Unnamed: 5'],\n      dtype='object')"
  },
  {
    "objectID": "03-pandas.html#dropping-columns",
    "href": "03-pandas.html#dropping-columns",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Dropping columns",
    "text": "Dropping columns\nIn some cases, we don’t really need the entire columns. Let’s drop the last column (that looks like an error in the CSV formatting).\n\nunemp_data.drop(unemp_data.columns[-1], axis = 1, inplace= True)\nunemp_data.head()\n\n\n\n\n\n\n\n\ndate\n16_19yrs\n20_24yrs\n25_54yrs\n55yrs_onwards\n\n\n\n\n0\n1948-01-01\n10.1\n6.6\n3.0\n3.6\n\n\n1\n1948-02-01\n11.5\n8.0\n3.6\n4.0\n\n\n2\n1948-03-01\n10.8\n8.6\n3.2\n3.5\n\n\n3\n1948-04-01\n8.8\n6.8\n3.2\n3.2\n\n\n4\n1948-05-01\n6.9\n6.3\n2.6\n2.9"
  },
  {
    "objectID": "03-pandas.html#renaming-columns",
    "href": "03-pandas.html#renaming-columns",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Renaming columns",
    "text": "Renaming columns\nSometimes the column names are not ideal. In our case, let’s give a name to each age group!\n\nunemp_data.columns = ['date', 'teenagers', 'young_adults', 'adults', 'seniors']\nprint(unemp_data.columns)\n\nIndex(['date', 'teenagers', 'young_adults', 'adults', 'seniors'], dtype='object')\n\n\nAlternatively, if you just want to rename specific columns:\nunemp_data.rename(columns={'16_19yrs': 'teenagers', '20_24yrs': 'young_adults'}, inplace = True)"
  },
  {
    "objectID": "03-pandas.html#data-preparation-analysis-and-visualization-tasks",
    "href": "03-pandas.html#data-preparation-analysis-and-visualization-tasks",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Data preparation, analysis, and visualization tasks",
    "text": "Data preparation, analysis, and visualization tasks\nData preparation, analysis, and visualization tasks will be different depends on the dataset and your goal. Specifically for our data, we will do the following:\n\nCheck for and remove all the missing values.\nWe are primarily interested in the young adult unemployment. Separate this data into a new dataframe called ya_unemp.\nRetrieve the months and years where the young adult rate is more than 10 percent and keep this on high_ya_unemp.\nAdd in a new column that tracks the total unemployment rate for each month.\nCalculate the quarterly mean unemployment rate.\nCalculate the year-on-year change of unemployment rate.\nPlot the unemployment rate over the years for each age group.\nAre there any specific month where the unemployment rate tends to be higher? Plot the data.\nAre there any outliers in the unemployment rate?"
  },
  {
    "objectID": "03-pandas.html#task-1---handling-missing-values",
    "href": "03-pandas.html#task-1---handling-missing-values",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 1 - Handling missing values",
    "text": "Task 1 - Handling missing values\nOther than info(), we can also use isnull() to check for null values\n\n# Check for missing values\nprint(unemp_data.isnull().sum())\n\ndate            0\nteenagers       0\nyoung_adults    0\nadults          0\nseniors         0\ndtype: int64"
  },
  {
    "objectID": "03-pandas.html#handling-missing-values-drop-or-no-drop",
    "href": "03-pandas.html#handling-missing-values-drop-or-no-drop",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Handling missing values: drop or no drop?",
    "text": "Handling missing values: drop or no drop?\nWe can drop those rows that contains null values with dropna()…\n\n# Drop rows with missing values (if any)\nunemp_data = unemp_data.dropna()\nprint(unemp_data.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 920 entries, 0 to 919\nData columns (total 5 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   date          920 non-null    object \n 1   teenagers     920 non-null    float64\n 2   young_adults  920 non-null    float64\n 3   adults        920 non-null    float64\n 4   seniors       920 non-null    float64\ndtypes: float64(4), object(1)\nmemory usage: 36.1+ KB\nNone\n\n\n… or we can also fill in the null values with something else, e.g. 0\nuemp_data = unemp_data.fillna(0)"
  },
  {
    "objectID": "03-pandas.html#task-2---retrieving-columns-a-single-column",
    "href": "03-pandas.html#task-2---retrieving-columns-a-single-column",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 2 - Retrieving columns: a single column",
    "text": "Task 2 - Retrieving columns: a single column\nAs the column names in DataFrame are indexed, we can simply call them by their column names! (Much more intuitive compared to Numpy)\n\nya_unemp = unemp_data['young_adults']\nya_unemp.head()\n\n\n\n0    6.6\n1    8.0\n2    8.6\n3    6.8\n4    6.3\nName: young_adults, dtype: float64"
  },
  {
    "objectID": "03-pandas.html#retrieving-columns-multiple-columns",
    "href": "03-pandas.html#retrieving-columns-multiple-columns",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Retrieving columns: multiple columns",
    "text": "Retrieving columns: multiple columns\nSimilarly, if we want to retrieve multiple columns, we can pass a list of column names to the dataframe and save these sliced columns into a new dataframe.\n\nya_unemp = unemp_data[['date', 'young_adults']]\nya_unemp.head()\n\n\n\n\n\n\n\n\n\n\ndate\nyoung_adults\n\n\n\n\n0\n1948-01-01\n6.6\n\n\n1\n1948-02-01\n8.0\n\n\n2\n1948-03-01\n8.6\n\n\n3\n1948-04-01\n6.8\n\n\n4\n1948-05-01\n6.3"
  },
  {
    "objectID": "03-pandas.html#task-3---filtering-rows-without-query",
    "href": "03-pandas.html#task-3---filtering-rows-without-query",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 3 - Filtering row(s): without query()",
    "text": "Task 3 - Filtering row(s): without query()\nWe can do it “raw” or us the query function from pandas. Here is how you can do it without the query() function:\n\ncriteria = unemp_data[\"young_adults\"] &gt; 10\nhigh_ya_unemp = unemp_data[criteria]\nhigh_ya_unemp.head()\n\n\n\n\n\n\n\n\n\n\ndate\nteenagers\nyoung_adults\nadults\nseniors\n\n\n\n\n17\n1949-06-01\n19.0\n10.1\n4.4\n4.9\n\n\n18\n1949-07-01\n16.0\n11.2\n5.3\n5.8\n\n\n19\n1949-08-01\n12.6\n10.4\n5.0\n5.3\n\n\n24\n1950-01-01\n17.7\n11.6\n6.2\n6.6\n\n\n25\n1950-02-01\n17.3\n12.2\n6.4\n7.0"
  },
  {
    "objectID": "03-pandas.html#filtering-rows-with-query",
    "href": "03-pandas.html#filtering-rows-with-query",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Filtering row(s): with query()",
    "text": "Filtering row(s): with query()\nAnd here is how you can do it with the query() function:\n\nprint(unemp_data.query('young_adults &gt; 10'))\n\n\n\n           date  teenagers  young_adults  adults  seniors\n17   1949-06-01       19.0          10.1     4.4      4.9\n18   1949-07-01       16.0          11.2     5.3      5.8\n19   1949-08-01       12.6          10.4     5.0      5.3\n24   1950-01-01       17.7          11.6     6.2      6.6\n25   1950-02-01       17.3          12.2     6.4      7.0\n..          ...        ...           ...     ...      ...\n873  2020-10-01       13.1          10.5     6.2      5.2\n875  2020-12-01       14.1          10.6     5.7      5.8\n876  2021-01-01       15.6          10.8     6.2      5.6\n878  2021-03-01       12.5          10.4     5.7      4.8\n880  2021-05-01        9.5          10.3     4.9      4.6\n\n[311 rows x 5 columns]"
  },
  {
    "objectID": "03-pandas.html#filtering-rows-with-query-and-save-result",
    "href": "03-pandas.html#filtering-rows-with-query-and-save-result",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Filtering row(s): with query() and save result",
    "text": "Filtering row(s): with query() and save result\nTake note that the previous code will simply print out the result! If you want to save the result, make sure to assign the result to a new dataframe.\n\nhigh_ya_unemp = unemp_data.query('young_adults &gt; 10')\nhigh_ya_unemp.head()\n\n\n\n\n\n\n\n\n\n\ndate\nteenagers\nyoung_adults\nadults\nseniors\n\n\n\n\n17\n1949-06-01\n19.0\n10.1\n4.4\n4.9\n\n\n18\n1949-07-01\n16.0\n11.2\n5.3\n5.8\n\n\n19\n1949-08-01\n12.6\n10.4\n5.0\n5.3\n\n\n24\n1950-01-01\n17.7\n11.6\n6.2\n6.6\n\n\n25\n1950-02-01\n17.3\n12.2\n6.4\n7.0"
  },
  {
    "objectID": "03-pandas.html#task-4---adding-new-columns",
    "href": "03-pandas.html#task-4---adding-new-columns",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 4 - Adding new column(s)",
    "text": "Task 4 - Adding new column(s)\nLet’s add a new column for total unemployment (sum of all age groups)\n\nunemp_data['total_unemployment'] = unemp_data['teenagers'] + unemp_data['young_adults'] + unemp_data['adults'] + unemp_data['seniors']\nunemp_data.head()\n\n\n\n\n\n\n\n\ndate\nteenagers\nyoung_adults\nadults\nseniors\ntotal_unemployment\n\n\n\n\n0\n1948-01-01\n10.1\n6.6\n3.0\n3.6\n23.3\n\n\n1\n1948-02-01\n11.5\n8.0\n3.6\n4.0\n27.1\n\n\n2\n1948-03-01\n10.8\n8.6\n3.2\n3.5\n26.1\n\n\n3\n1948-04-01\n8.8\n6.8\n3.2\n3.2\n22.0\n\n\n4\n1948-05-01\n6.9\n6.3\n2.6\n2.9\n18.7"
  },
  {
    "objectID": "03-pandas.html#learning-check-1",
    "href": "03-pandas.html#learning-check-1",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Learning Check #1",
    "text": "Learning Check #1\nRetrieve data where the employment rate for adults are between 9 to 12 inclusive. Save only the date and adults column to a new dataframe called adult_unemp\n\n\nCode\nadult_unemp = unemp_data[['date', 'adults']].query('adults &gt;= 9 & adults &lt;= 12')\nprint(adult_unemp.head())\nprint(adult_unemp.shape)\n\n\n           date  adults\n419  1982-12-01     9.0\n420  1983-01-01     9.7\n421  1983-02-01     9.6\n422  1983-03-01     9.2\n744  2010-01-01     9.6\n(10, 2)"
  },
  {
    "objectID": "03-pandas.html#side-quest-datetime-object",
    "href": "03-pandas.html#side-quest-datetime-object",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Side quest: DateTime Object",
    "text": "Side quest: DateTime Object\n\nA DateTime object in Python, provided by the datetime module, represents a specific point in time, including the year, month, day, hour, minute, second, and microsecond.\nIt can be used to manipulate dates and times, perform arithmetic on dates, and format dates into other string representation e.g. from dd/mm/yyyy to yyyy-mm-dd.\n\n\nfrom datetime import datetime\n\nnow = datetime.now()\nprint(\"Current Date and Time:\", now)\n\nCurrent Date and Time: 2024-09-27 19:47:25.431685"
  },
  {
    "objectID": "03-pandas.html#components-of-datetime",
    "href": "03-pandas.html#components-of-datetime",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Components of DateTime",
    "text": "Components of DateTime\nThe DateTime object consists of multiple components that represent different parts of the date and time, such as year, month, day, hour, minute, second, etc. You can access these components individually.\n\n# Extract year, month, and day from a specific date\nnow = datetime.now()\n\n# Access individual components\nprint(\"Year:\", now.year)\nprint(\"Month:\", now.month)\nprint(\"Day:\", now.day)\nprint(\"Hour:\", now.hour)\nprint(\"Minute:\", now.minute)\nprint(\"Second:\", now.second)\n\nYear: 2024\nMonth: 9\nDay: 27\nHour: 19\nMinute: 47\nSecond: 25"
  },
  {
    "objectID": "03-pandas.html#datetime-operations",
    "href": "03-pandas.html#datetime-operations",
    "title": "Introduction to Pandas and Seaborn",
    "section": "DateTime operations",
    "text": "DateTime operations\n\nYou can perform various operations with DateTime objects, such as calculating the difference between two dates or adding/subtracting time with the help of timedelta.\nThese are essential for time series data manipulation, where date-based arithmetic is often required.\n\n\nfrom datetime import timedelta\n\nnow = datetime.now()\n\nlast_week = now - timedelta(days=7)\nprint(\"1 week ago:\", last_week)\n\n1 week ago: 2024-09-20 19:47:25.457070"
  },
  {
    "objectID": "03-pandas.html#back-to-main-quest-time-series-with-dataframe",
    "href": "03-pandas.html#back-to-main-quest-time-series-with-dataframe",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Back to Main Quest: Time Series with DataFrame",
    "text": "Back to Main Quest: Time Series with DataFrame\nLet’s index the rows under date column as a DateTime index.\n\n1unemp_data['date'] = pd.to_datetime(unemp_data['date'], format=\"%Y-%m-%d\")\n2unemp_data.set_index('date', inplace=True)\n\n\n1\n\nConvert the data type under date column from string to DateTime object\n\n2\n\nSet the date column as the index.\n\n\n\n\n\n\nYou can refer to this page to see how to format the string expression of DateTime object: https://www.w3schools.com/python/python_datetime.asp"
  },
  {
    "objectID": "03-pandas.html#datetime-is-the-index-now-what",
    "href": "03-pandas.html#datetime-is-the-index-now-what",
    "title": "Introduction to Pandas and Seaborn",
    "section": "DateTime is the index, now what?",
    "text": "DateTime is the index, now what?\nLet’s check on the dataframe once more, to make sure that it is indexed as intended:\n\nunemp_data.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 920 entries, 1948-01-01 to 2024-08-01\nData columns (total 5 columns):\n #   Column              Non-Null Count  Dtype  \n---  ------              --------------  -----  \n 0   teenagers           920 non-null    float64\n 1   young_adults        920 non-null    float64\n 2   adults              920 non-null    float64\n 3   seniors             920 non-null    float64\n 4   total_unemployment  920 non-null    float64\ndtypes: float64(5)\nmemory usage: 43.1 KB\n\n\nIf all goes well, the date column should be part of the index now."
  },
  {
    "objectID": "03-pandas.html#extra-checks-with-time-series",
    "href": "03-pandas.html#extra-checks-with-time-series",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Extra checks with Time Series",
    "text": "Extra checks with Time Series\nOther things that we may want to check with Time Series is the date range of our data.\n\nprint(\"start date\", unemp_data.index.min())\nprint(\"end date\", unemp_data.index.max())\nprint(\"length\", unemp_data.index.max() - unemp_data.index.min())\n\nstart date 1948-01-01 00:00:00\nend date 2024-08-01 00:00:00\nlength 27972 days 00:00:00"
  },
  {
    "objectID": "03-pandas.html#retrieve-specific-date-range",
    "href": "03-pandas.html#retrieve-specific-date-range",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Retrieve specific date range",
    "text": "Retrieve specific date range\nNow that the index is a DateTime object, we can easily retrieve specific date range! Let’s say we would like retrieve unemployment rate for during COVID, which will be March 2020 to May 2023.\n\nunemp_data_covid = unemp_data.loc['2020-03':'2023-05']\nprint(unemp_data_covid.head())\n\n            teenagers  young_adults  adults  seniors  total_unemployment\ndate                                                                    \n2020-03-01       13.7           8.6     3.9      3.5                29.7\n2020-04-01       32.2          25.0    12.6     13.4                83.2\n2020-05-01       30.7          23.2    11.2     11.5                76.6\n2020-06-01       24.5          20.1     9.7      9.7                64.0\n2020-07-01       19.1          18.2     9.3      9.0                55.6"
  },
  {
    "objectID": "03-pandas.html#task-5---resampling-to-quarterly-data-and-get-the-quarterly-mean",
    "href": "03-pandas.html#task-5---resampling-to-quarterly-data-and-get-the-quarterly-mean",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 5 - Resampling to Quarterly data and get the quarterly mean",
    "text": "Task 5 - Resampling to Quarterly data and get the quarterly mean\nWith time series, we can calculate the quarterly average based on the monthly data with resample()\n\nquarterly_data = unemp_data.resample('Q').mean()\nprint(quarterly_data.head())\n\n            teenagers  young_adults    adults   seniors  total_unemployment\ndate                                                                       \n1948-03-31  10.800000      7.733333  3.266667  3.700000           25.500000\n1948-06-30   9.700000      6.466667  2.733333  2.900000           21.800000\n1948-09-30   8.933333      5.500000  2.766667  2.700000           19.900000\n1948-12-31   7.066667      4.933333  2.600000  3.166667           17.766667\n1949-03-31  12.033333      8.700000  4.366667  5.000000           30.100000"
  },
  {
    "objectID": "03-pandas.html#resampling-to-yearly-data",
    "href": "03-pandas.html#resampling-to-yearly-data",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Resampling to Yearly data",
    "text": "Resampling to Yearly data\nLet’s find out what is the highest unemployment rate for each year!\n\nyearly_data = unemp_data.resample('Y').max()\nprint(yearly_data.head())\n\n            teenagers  young_adults  adults  seniors  total_unemployment\ndate                                                                    \n1948-12-31       13.4           8.6     3.6      4.0                27.1\n1949-12-31       19.0          11.2     5.3      5.8                38.4\n1950-12-31       17.7          12.2     6.4      7.0                42.9\n1951-12-31       12.2           5.0     3.6      4.9                23.1\n1952-12-31       12.2           5.4     3.2      3.4                21.7"
  },
  {
    "objectID": "03-pandas.html#saving-into-a-csv",
    "href": "03-pandas.html#saving-into-a-csv",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Saving into a CSV",
    "text": "Saving into a CSV\nLet’s save the quarterly data to a CSV!\n\nquarterly_data.to_csv(\"data-output/yearly-unemployment-age.csv\")"
  },
  {
    "objectID": "03-pandas.html#changing-the-frequency-of-time-series-more-granular",
    "href": "03-pandas.html#changing-the-frequency-of-time-series-more-granular",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Changing the frequency of Time Series: More granular",
    "text": "Changing the frequency of Time Series: More granular\nLet’s say we would like get a weekly time series. Since our data is a monthly one, there will be rows with empty values if we change the frequency. There are several methods that we can employ here to fill this empty values:\n\nbackfill\nforward fill\ninterpolate\n\n\nunemp_data_weekly = unemp_data.resample('1W').ffill()\nprint(unemp_data_weekly.tail())\n\n            teenagers  young_adults  adults  seniors  total_unemployment\ndate                                                                    \n2024-07-07       13.2           8.1     3.8      3.3                28.4\n2024-07-14       13.2           8.1     3.8      3.3                28.4\n2024-07-21       13.2           8.1     3.8      3.3                28.4\n2024-07-28       13.2           8.1     3.8      3.3                28.4\n2024-08-04       14.1           8.0     3.7      3.1                28.9"
  },
  {
    "objectID": "03-pandas.html#task-6---calculate-year-on-year-changes-for-young-adults",
    "href": "03-pandas.html#task-6---calculate-year-on-year-changes-for-young-adults",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 6 - Calculate year-on-year changes for young adults",
    "text": "Task 6 - Calculate year-on-year changes for young adults\nLet’s get the year-on-year change for young adults age group.\n\nunemp_data['ya_YoY_pctchange'] = unemp_data['young_adults'].pct_change(periods=12) # multiply by 100 to get the %\nprint(unemp_data.tail())\n\n            teenagers  young_adults  adults  seniors  total_unemployment  \\\ndate                                                                       \n2024-04-01       10.4           6.0     3.0      2.8                22.2   \n2024-05-01       12.1           8.0     3.1      2.5                25.7   \n2024-06-01       14.4           8.2     3.5      2.9                29.0   \n2024-07-01       13.2           8.1     3.8      3.3                28.4   \n2024-08-01       14.1           8.0     3.7      3.1                28.9   \n\n            ya_YoY_pctchange  \ndate                          \n2024-04-01          0.250000  \n2024-05-01          0.269841  \n2024-06-01          0.223881  \n2024-07-01          0.125000  \n2024-08-01          0.111111"
  },
  {
    "objectID": "03-pandas.html#calculate-the-changes-for-each-month",
    "href": "03-pandas.html#calculate-the-changes-for-each-month",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Calculate the changes for each month",
    "text": "Calculate the changes for each month\nTo capture the direction and magnitude of changes in unemployment rate each month, use diff() function.\n\nunemp_data['changes_ya'] = unemp_data['young_adults'].diff()\nprint(unemp_data['changes_ya'].head(7))\n\ndate\n1948-01-01    NaN\n1948-02-01    1.4\n1948-03-01    0.6\n1948-04-01   -1.8\n1948-05-01   -0.5\n1948-06-01    0.0\n1948-07-01    0.1\nName: changes_ya, dtype: float64"
  },
  {
    "objectID": "03-pandas.html#visualize-the-changes",
    "href": "03-pandas.html#visualize-the-changes",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Visualize the changes",
    "text": "Visualize the changes\nPandas is built on top of NumPy and integrates well with Matplotlib, so it is super easy to plot data right away—especially now that we’ve set the index!\n\nunemp_data['changes_ya'].plot()"
  },
  {
    "objectID": "03-pandas.html#learning-check-2",
    "href": "03-pandas.html#learning-check-2",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Learning Check #2",
    "text": "Learning Check #2\nChange the frequency of the time series to weekly, and interpolate the numbers. Save this new series into unemp_weekly_interpolate\n\n\nCode\nunemp_weekly_interpolate = unemp_data.resample('1W').interpolate()\nprint(unemp_weekly_interpolate.tail())\n\n\n            teenagers  young_adults  adults  seniors  total_unemployment  \\\ndate                                                                       \n2024-07-07       13.1           6.6     3.0      2.5                25.2   \n2024-07-14       13.1           6.6     3.0      2.5                25.2   \n2024-07-21       13.1           6.6     3.0      2.5                25.2   \n2024-07-28       13.1           6.6     3.0      2.5                25.2   \n2024-08-04       13.1           6.6     3.0      2.5                25.2   \n\n            ya_YoY_pctchange  changes_ya  \ndate                                      \n2024-07-07          0.015385        -0.5  \n2024-07-14          0.015385        -0.5  \n2024-07-21          0.015385        -0.5  \n2024-07-28          0.015385        -0.5  \n2024-08-04          0.015385        -0.5"
  },
  {
    "objectID": "03-pandas.html#whats-seaborn",
    "href": "03-pandas.html#whats-seaborn",
    "title": "Introduction to Pandas and Seaborn",
    "section": "What’s Seaborn?",
    "text": "What’s Seaborn?\n\n\n\n\n\nSeaborn is a Python data visualization library based on matplotlib. It provides a high-level interface for drawing attractive and informative statistical graphics. 1\n\n\nWell-established Python library for data visualization\nCheatsheet by Datacamp here: https://python-graph-gallery.com/cheat-sheets/\n\n\nSome setups we can do:\n\nimport seaborn as sns\nsns.set_style(\"whitegrid\")\nsns.set_palette(\"husl\")\n\nhttps://seaborn.pydata.org/"
  },
  {
    "objectID": "03-pandas.html#task-7---plot-the-entire-time-series",
    "href": "03-pandas.html#task-7---plot-the-entire-time-series",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 7 - Plot the entire time series",
    "text": "Task 7 - Plot the entire time series\nLet’s plot the unemployment rate over the years for each age group!\n\nunemp_data.plot()\nplt.title('Unemployment Rate for Young Adults')\nplt.ylabel('Unemployment Rate (%)')\nplt.show()"
  },
  {
    "objectID": "03-pandas.html#task-7---plot-the-entire-time-series-output",
    "href": "03-pandas.html#task-7---plot-the-entire-time-series-output",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 7 - Plot the entire time series",
    "text": "Task 7 - Plot the entire time series"
  },
  {
    "objectID": "03-pandas.html#plotting-some-parts-of-the-time-series",
    "href": "03-pandas.html#plotting-some-parts-of-the-time-series",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Plotting some parts of the time series",
    "text": "Plotting some parts of the time series\nClearly, there are some columns that we may want to skip. To do this, we can reshape the data shape into long format using melt().\nLet’s say we only want to visualize teenagers and young_adults.\n\n1youth_data = unemp_data[['teenagers', 'young_adults']]\n2youth_data = youth_data.reset_index()\n3youth_data_melted = youth_data.melt(id_vars='date', value_vars=['teenagers', 'young_adults'], var_name='age_group', value_name='unemployment_rate')\n\n\n1\n\nRetrieve the columns that we need (index will be automatically included)\n\n2\n\nReset the index, so that it’s back to normal column.\n\n3\n\nUse the melt() function to “melt” the wide data into long format"
  },
  {
    "objectID": "03-pandas.html#wide-data-vs-long-data",
    "href": "03-pandas.html#wide-data-vs-long-data",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Wide data vs Long data",
    "text": "Wide data vs Long data\nCheck out the difference!\n\n\nWide Data\n\n\n            teenagers  young_adults\ndate                               \n1948-01-01       10.1           6.6\n1948-02-01       11.5           8.0\n1948-03-01       10.8           8.6\n1948-04-01        8.8           6.8\n1948-05-01        6.9           6.3\n...               ...           ...\n2024-04-01       10.4           6.0\n2024-05-01       12.1           8.0\n2024-06-01       14.4           8.2\n2024-07-01       13.2           8.1\n2024-08-01       14.1           8.0\n\n[920 rows x 2 columns]\n\n\n\nLong Data\n\n\n           date     age_group  unemployment_rate\n0    1948-01-01     teenagers               10.1\n1    1948-02-01     teenagers               11.5\n2    1948-03-01     teenagers               10.8\n3    1948-04-01     teenagers                8.8\n4    1948-05-01     teenagers                6.9\n...         ...           ...                ...\n1835 2024-04-01  young_adults                6.0\n1836 2024-05-01  young_adults                8.0\n1837 2024-06-01  young_adults                8.2\n1838 2024-07-01  young_adults                8.1\n1839 2024-08-01  young_adults                8.0\n\n[1840 rows x 3 columns]"
  },
  {
    "objectID": "03-pandas.html#visualizing-is-much-easier-with-long-data",
    "href": "03-pandas.html#visualizing-is-much-easier-with-long-data",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Visualizing is much easier with long data",
    "text": "Visualizing is much easier with long data\nWe can now fit the things we want in a single line like so:\n\nsns.lineplot(data=youth_data_melted, x='date', y='unemployment_rate', hue='age_group')"
  },
  {
    "objectID": "03-pandas.html#making-visualization-easier-capture-month-info-into-a-separate-column",
    "href": "03-pandas.html#making-visualization-easier-capture-month-info-into-a-separate-column",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Making visualization easier: Capture month info into a separate column",
    "text": "Making visualization easier: Capture month info into a separate column\nWith DateTime object as the index, we can easily capture the month info. This would be useful to see whether certain months tend to have higher unemployment rate based on this data.\n\nunemp_data['month'] = unemp_data.index.month\nprint(unemp_data.head())\n\n            teenagers  young_adults  adults  seniors  total_unemployment  \\\ndate                                                                       \n1948-01-01       10.1           6.6     3.0      3.6                23.3   \n1948-02-01       11.5           8.0     3.6      4.0                27.1   \n1948-03-01       10.8           8.6     3.2      3.5                26.1   \n1948-04-01        8.8           6.8     3.2      3.2                22.0   \n1948-05-01        6.9           6.3     2.6      2.9                18.7   \n\n            ya_YoY_pctchange  changes_ya  month  \ndate                                             \n1948-01-01               NaN         NaN      1  \n1948-02-01               NaN         1.4      2  \n1948-03-01               NaN         0.6      3  \n1948-04-01               NaN        -1.8      4  \n1948-05-01               NaN        -0.5      5"
  },
  {
    "objectID": "03-pandas.html#aggregate-statistics",
    "href": "03-pandas.html#aggregate-statistics",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Aggregate statistics",
    "text": "Aggregate statistics\nLet’s calculate the average unemployment rate for each month based on this data.\n\nunemp_permonth = unemp_data.groupby('month').mean()\nprint(unemp_permonth)\n\n       teenagers  young_adults    adults   seniors  total_unemployment  \\\nmonth                                                                    \n1      16.612987     10.276623  5.159740  4.264935           36.314286   \n2      16.648052     10.207792  5.135065  4.290909           36.281818   \n3      15.977922      9.727273  4.905195  4.138961           34.749351   \n4      15.248052      9.076623  4.589610  3.902597           32.816883   \n5      15.981818      9.262338  4.322078  3.631169           33.197403   \n6      19.632468      9.836364  4.367532  3.646753           37.483117   \n7      16.216883      9.293506  4.528571  3.781818           33.820779   \n8      14.025974      8.961039  4.501299  3.703896           31.192208   \n9      15.543421      8.925000  4.292105  3.468421           32.228947   \n10     15.027632      8.500000  4.178947  3.432895           31.139474   \n11     15.502632      8.493421  4.297368  3.618421           31.911842   \n12     14.502632      8.522368  4.430263  3.686842           31.142105   \n\n       ya_YoY_pctchange  changes_ya  \nmonth                                \n1              0.023639    1.802632  \n2              0.027765   -0.068831  \n3              0.023718   -0.480519  \n4              0.056689   -0.650649  \n5              0.053468    0.185714  \n6              0.040224    0.574026  \n7              0.043577   -0.542857  \n8              0.035135   -0.332468  \n9              0.033654   -0.048684  \n10             0.035276   -0.425000  \n11             0.028284   -0.006579  \n12             0.024550    0.028947"
  },
  {
    "objectID": "03-pandas.html#task-8---months-where-unemployment-rate-then-to-be-high",
    "href": "03-pandas.html#task-8---months-where-unemployment-rate-then-to-be-high",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 8 - Months where unemployment rate then to be high",
    "text": "Task 8 - Months where unemployment rate then to be high\nWhich month seems to have the highest unemployment rate on average?\n\nsns.barplot(data = unemp_permonth, x = unemp_permonth.index, y = 'young_adults')"
  },
  {
    "objectID": "03-pandas.html#task-9---finding-outliers",
    "href": "03-pandas.html#task-9---finding-outliers",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Task 9 - Finding outliers",
    "text": "Task 9 - Finding outliers\nLet’s see how unemployment rate fared each month for young_adults. Are there any outliers?\n\nsns.boxplot(x = 'month', y = 'young_adults', data=unemp_data[['month', 'young_adults']])"
  },
  {
    "objectID": "03-pandas.html#more-seaborn-scatterplot",
    "href": "03-pandas.html#more-seaborn-scatterplot",
    "title": "Introduction to Pandas and Seaborn",
    "section": "More Seaborn: Scatterplot",
    "text": "More Seaborn: Scatterplot\nSeaborn can do many other visualizations as well. For example, let’s try plotting a scatterplot of young_adults and seniors\n\nsns.scatterplot(x = 'young_adults', y = 'seniors', data = unemp_data)"
  },
  {
    "objectID": "03-pandas.html#more-seaborn-regplot",
    "href": "03-pandas.html#more-seaborn-regplot",
    "title": "Introduction to Pandas and Seaborn",
    "section": "More Seaborn: Regplot",
    "text": "More Seaborn: Regplot\nLet’s try plotting a regression plot of young_adults and seniors\n\nsns.regplot(x = 'young_adults', y = 'seniors', data = unemp_data)"
  },
  {
    "objectID": "03-pandas.html#learning-check-3",
    "href": "03-pandas.html#learning-check-3",
    "title": "Introduction to Pandas and Seaborn",
    "section": "Learning Check #3",
    "text": "Learning Check #3\nPlot the unemployment rate fared each month for young_adults with violin plot to see the distribution better.\n\n\nCode\nsns.violinplot(x = 'month', y = 'young_adults', data=unemp_data[['month', 'young_adults']])"
  },
  {
    "objectID": "01-basics.html#preamble",
    "href": "01-basics.html#preamble",
    "title": "Introduction to Python",
    "section": "Preamble",
    "text": "Preamble\n\n\nAbout me:\n\nLibrarian, Research & Data Services team, SMU Libraries.\nBachelor of IT, MSc in Info Studies.\nHave been with SMU since the pandemic era (2021).\n\nAbout this workshop:\n\nLive-coding format; code along with me!\nGoal of workshop: to give you enough fundamentals (at least to the point where ChatGPT can’t bluff you so easily) and confidence to explore python on your own.\nComes with 3 quizzes that you can do at home - one quiz after each session, except for the last one.\nDon’t be afraid to ask for help! We are all here to learn"
  },
  {
    "objectID": "01-basics.html#about-the-workshop",
    "href": "01-basics.html#about-the-workshop",
    "title": "Introduction to Python",
    "section": "About the workshop",
    "text": "About the workshop\n\nLive coding & lots of hands-on\nTake-home quiz after session 1, 2, and 3 to reinforce the learning - Link will be put on the course website.\nOnly for session 4: a small group activity at the second half of the session.\n\nChoose an economic indicator from Federal Reserve Economic Data (FRED) e.g. Civilian Unemployment Rate.\nApply your Python knowledge to create a “storyboard” with visualizations to derive your economic outlook."
  },
  {
    "objectID": "01-basics.html#overview-for-today",
    "href": "01-basics.html#overview-for-today",
    "title": "Introduction to Python",
    "section": "Overview for today",
    "text": "Overview for today\n\nIntroduction to Visual Studio\nIntroduction to Python - objects, values, and types\nHandling Lists\nHandling Loops and Conditionals"
  },
  {
    "objectID": "01-basics.html#why-python",
    "href": "01-basics.html#why-python",
    "title": "Introduction to Python",
    "section": "Why Python?",
    "text": "Why Python?\nQ: What is Python, actually?\nA: Python is a general-purpose programming language used for a wide variety of applications. Website, games, CAD applications, web applications, AI, etc.\nQ: Why should I learn Python?\nA: It’s one of the most popular programming language and the most dominant language in AI, ML, and data analytics field. It’s a useful skill to know if you plan to go into those fields or anything adjacent."
  },
  {
    "objectID": "01-basics.html#how-do-you-run-python",
    "href": "01-basics.html#how-do-you-run-python",
    "title": "Introduction to Python",
    "section": "How do you run python?",
    "text": "How do you run python?\n\n\nIf it’s a .py file…\n\nA regular python file.\nA plain text and contains just python codes\nCan be edited and run on Visual Studio Code, PyCharm, SPyder, etc or the terminal/command prompt.\n\n\nIf it’s a .ipynb file…\n\nipynb stands for Interactive Python Notebook file\nContains the notebook code, the execution results and other internal settings in a specific format\nCan be edited and run on Jupyter Notebook/Lab, Google Colab, and also Visual Studio (with the Jupyter Notebook extension)"
  },
  {
    "objectID": "01-basics.html#whats-.py-and-.ipynb",
    "href": "01-basics.html#whats-.py-and-.ipynb",
    "title": "Introduction to Python",
    "section": "What’s .py and .ipynb??",
    "text": "What’s .py and .ipynb??\n\n\nIf it’s a .py file…\n\n\nIf it’s a .ipynb file…"
  },
  {
    "objectID": "01-basics.html#why-the-different-file-types",
    "href": "01-basics.html#why-the-different-file-types",
    "title": "Introduction to Python",
    "section": "Why the different file types?",
    "text": "Why the different file types?\n\n\nIf it’s a .py file…\n\nFor “production” uses e.g., creating apps, industrial deployments\nExecuting the file will run all the codes contained inside the file.\n\n\nIf it’s a .ipynb file…\n\nUsed a lot for academic / scientific purposes; great for quick experiments or teaching / presentation.\nCodes will be executed on per-block basis (we will see this in action later on)"
  },
  {
    "objectID": "01-basics.html#suggested-structure-of-workspace-directory",
    "href": "01-basics.html#suggested-structure-of-workspace-directory",
    "title": "Introduction to Python",
    "section": "(Suggested) structure of workspace directory",
    "text": "(Suggested) structure of workspace directory\n\nIn your laptop, navigate to where you usually keep your files, and create a folder called 2024-09-python-workshop. This folder will be our “workspace” where we keep our scripts and data files.\nInside your workspace folder, create the following sub-folders:\n\ndata - we will save our raw data here. It’s best practice to keep the data here untouched.\ndata-output - if we need to modify raw data, store the modified version here.\nfig-output - we will save all the graphics we created here!\n\nStart VS Code.\nGo to File &gt; Open Folder.\nOpen the 2024-09-python-workshop folder we just created."
  },
  {
    "objectID": "01-basics.html#best-practice-virtual-environment",
    "href": "01-basics.html#best-practice-virtual-environment",
    "title": "Introduction to Python",
    "section": "Best practice: Virtual Environment",
    "text": "Best practice: Virtual Environment\n\n\n\n\n\n\nVirtual environment helps us to ensure that any packages we install will be isolated from other environments, including the global interpreter. This helps prevent issues that can occur due to conflicting package versions - especially useful for reproducibility!\n\n\n\n\nOpen the Command Palette (Ctrl + Shift + P on Windows - Cmd + Shift + P on Macbook).\nType Python: Create Environment, and select the command. Choose Venv.\n\n\n\nSelect the Python interpreter that we installed in the pre-workshop activity. Give VS Code a few minutes to setup the environment."
  },
  {
    "objectID": "01-basics.html#create-new-file",
    "href": "01-basics.html#create-new-file",
    "title": "Introduction to Python",
    "section": "Create new file",
    "text": "Create new file\n\nOpen the Command Palette (Ctrl + Shift + P on Windows - Cmd + Shift + P on Macbook).\nType Python: New Python File, and select the command.\nRename the file to 01-intro.py"
  },
  {
    "objectID": "01-basics.html#some-basic-glossary-for-your-reference",
    "href": "01-basics.html#some-basic-glossary-for-your-reference",
    "title": "Introduction to Python",
    "section": "Some basic glossary (for your reference)",
    "text": "Some basic glossary (for your reference)\n\n\n\nObjects\n\nIn Python, everything is an object. An object is a piece of data that can have attributes and methods associated with it.\n\nValue\n\nThe actual data stored in a variable or object. It can be a number, string, list, or any other data type.\n\nVariable\n\nA value that has a name associated with it.\n\nAssign\n\nTo give a value to a variable. This is done using the equals sign (=).\n\n\n\n\nFunction\n\nA reusable block of code that performs a specific task. Functions can take inputs (arguments) and return outputs.\n\nCall\n\nTo execute or run a function. This is done by using the function name followed by parentheses.\n\nArguments\n\nValues passed to a function when it is called. These values are used by the function to perform its task.\n\nOptions/Parameters\n\nVariables defined in a function’s declaration that act as placeholders for arguments. They specify what kind of data the function expects to receive.\n\nPackages\n\nCollections of related modules that extend Python’s capabilities. They can be installed and imported to add new functionalities within your workspace."
  },
  {
    "objectID": "01-basics.html#running-your-python-code",
    "href": "01-basics.html#running-your-python-code",
    "title": "Introduction to Python",
    "section": "Running your python code",
    "text": "Running your python code\nType the following in your .py file…\n\nprint(\"Hello World!\")\n5 + 5 \n\n…and then click on the run button to run the script\n\nYou should see “Hello World!” and a 10 printed at the Terminal window at the bottom"
  },
  {
    "objectID": "01-basics.html#built-in-functions",
    "href": "01-basics.html#built-in-functions",
    "title": "Introduction to Python",
    "section": "Built-in functions",
    "text": "Built-in functions\n\nFunctions will typically have brackets () at the end of their name.\nPython has a built-in function called print() that prints things as text.\nCall the function (i.e., tell Python to run it) by using its name.\n\n\nprint(10 - 5)\nprint(10 * 2)\nprint(\"hello world\")\n\n5\n20\nhello world"
  },
  {
    "objectID": "01-basics.html#comments",
    "href": "01-basics.html#comments",
    "title": "Introduction to Python",
    "section": "Comments",
    "text": "Comments\nUse comments to add a layer of documentation to your code. E.g., explain what a block of code does, etc.\nComments always start with a hashtag #\n\nprint(10 - 5)\nprint(10 * 2)\nprint(\"hello world\")\n# print(\"python won't print this!\")\n\n5\n20\nhello world\n\n\nFeel free to use this method to add your own notes throughout the workshop!"
  },
  {
    "objectID": "01-basics.html#whats-a-variable",
    "href": "01-basics.html#whats-a-variable",
    "title": "Introduction to Python",
    "section": "What’s a variable?",
    "text": "What’s a variable?\nVariables are names for values. # In Python, the = symbol assigns the value on the right to the variable on the left.\nOnce you declare a variable, you must assign value to it.\n\ngreetings = \"Hello World!\"\nage = 25\n\nVariable names criteria:\n\ncannot start with a digit\nalphanumeric only (underscores are a-OK)\ncase sensitive\nshould be meaningful (e.g. quarter1_growth instead of just q1g)"
  },
  {
    "objectID": "01-basics.html#on-creating-variables",
    "href": "01-basics.html#on-creating-variables",
    "title": "Introduction to Python",
    "section": "On creating variables",
    "text": "On creating variables\nVariables must be created before they are used.\nIf a variable doesn’t exist yet, or if the name has been mis-spelled, Python reports an error. e.g. if you try to simply declare a variable called name but didn’t assign any value to it, Python will not like that and reports an error!\nname  # This  will give you an error."
  },
  {
    "objectID": "01-basics.html#things-we-can-do-with-variables",
    "href": "01-basics.html#things-we-can-do-with-variables",
    "title": "Introduction to Python",
    "section": "Things we can do with variables",
    "text": "Things we can do with variables\nWe can pass variables to functions, e.g. let’s pass the greetings variable to print() function. This should print out the value of greetings.\n\n\nprint(greetings)\nprint(\"today's greetings:\", greetings)\n\n\nHello World!\ntoday's greetings: Hello World!\n\n\nWe can also update the value contained inside a variable. Let’s try adding 10 to variable age.\n\n\nage = age + 10\nprint(\"Age in ten years from now:\", age)\n\n\nAge in ten years from now: 35\n\n\nYou can also assign a variable value to another variable\n\n\ncontinent = \"Asia\"\nposition = continent  \nprint(\"Position:\", position)  \nprint(\"Continent:\", continent)  \n\n\nPosition: Asia\nContinent: Asia"
  },
  {
    "objectID": "01-basics.html#learning-check-1",
    "href": "01-basics.html#learning-check-1",
    "title": "Introduction to Python",
    "section": "Learning Check #1",
    "text": "Learning Check #1\nWhat is the final value of variable position below?\ninitial = \"up\"\nposition = initial\ninitial = \"down\"\nWhat is the final value of variable country_1 below?\ncountry_1 = \"Australia\"\ncountry_2 = \"New Zealand\"\ntemp = country_1\ncountry_1 = country_2\ncountry_2 = temp"
  },
  {
    "objectID": "01-basics.html#refresher-quantitative-data-types-in-econs-and-social-sciences",
    "href": "01-basics.html#refresher-quantitative-data-types-in-econs-and-social-sciences",
    "title": "Introduction to Python",
    "section": "Refresher: Quantitative Data Types in Econs and Social Sciences",
    "text": "Refresher: Quantitative Data Types in Econs and Social Sciences\n\n\nNon-Continuous Data\n\nNominal/Categorical: Non-ordered, non-numerical data, used to represent qualitative attribute. e.g. Country, Employment status\nOrdinal: Ordered non-numerical data. e.g. Nutri-grade ratings\nDiscrete: Numerical data that can only take specific value (usually integers) e.g. Shoe size, clothing size\nBinary: Nominal data with only two possible outcome. e.g. pass/fail, yes/no, survive/not survive\n\n\nContinuous Data\n\nInterval: Numerical data that can take any value within a range. It does not have a “true zero”. e.g. Temperature of 0 C does not represent absence of heat.\nRatio: Numerical data that can take any value within a range. it has a “true zero”. e.g. annual income of 0 represents no income."
  },
  {
    "objectID": "01-basics.html#basic-data-types-in-python",
    "href": "01-basics.html#basic-data-types-in-python",
    "title": "Introduction to Python",
    "section": "Basic data types in Python",
    "text": "Basic data types in Python\n\nIntegers (int): Whole numbers without a decimal point. Examples: 5, -3, 0\nFloating-point numbers (float): Numbers with a decimal point. Examples: 3.14, -0.5, 2.0\nStrings (str): Sequences of characters enclosed in quotes. Examples: “Hello”, ‘Python’\nBooleans (bool): Logical values representing True or False. Examples: True, False\nNone: A special type representing the absence of a value\n\n\ncountry = \"Singapore\"  # string\npublic_holidays = 11  # integer\navg_temp = 27.8  # float\npart_of_asean = True  # Boolean"
  },
  {
    "objectID": "01-basics.html#why-do-i-need-to-care-about-these-data-types",
    "href": "01-basics.html#why-do-i-need-to-care-about-these-data-types",
    "title": "Introduction to Python",
    "section": "Why do I need to care about these data types?",
    "text": "Why do I need to care about these data types?\nBecause a value’s data type determines what the program can do to it.\nFor example, the calculations below work on int data type\n\n\nprint(public_holidays - 5)  \n\n\n6\n\n\nBut the above operation won’t work on a string\nprint(country - \"pore\") \\# this will give an error!\nHowever you can use “+” and “*” on strings\n\n\nprint(country + \" best\")  # this works for string, though.\nprint(country * 4)  # this also works\nprint(\"=\" * 10)  # this also works\nprint(len(country))  # this would print out the number of characters a string has\n\n\nSingapore best\nSingaporeSingaporeSingaporeSingapore\n==========\n9"
  },
  {
    "objectID": "01-basics.html#converting-data-types-to-one-another",
    "href": "01-basics.html#converting-data-types-to-one-another",
    "title": "Introduction to Python",
    "section": "Converting data types to one another",
    "text": "Converting data types to one another\nSome data types need to be converted before we can do some operations on them i.e. this will give you an error.\nprint(\"10\" + 2) \nHere is how you can convert the data types:\n\nprint(\"10\" + str(2))  # convert to string\nprint(int(10) + 2)  # convert to int\n\n102\n12"
  },
  {
    "objectID": "01-basics.html#take-note-of-variables-assignment-placement",
    "href": "01-basics.html#take-note-of-variables-assignment-placement",
    "title": "Introduction to Python",
    "section": "Take note of variables assignment placement",
    "text": "Take note of variables assignment placement\nTake note of the execution order of your variables! They only change value when something is assigned to them.\n\npublic_holiday = 11  # initial value \nnew_holidays = public_holiday + 5\npublic_holiday = 10  # we update the variable\nprint(\"Public holiday:\", public_holiday) \nprint(\"New holidays:\", new_holidays) \n\nPublic holiday: 10\nNew holidays: 16\n\n\nUpdating the value of public_holiday will not auto-update the value of new_holidays."
  },
  {
    "objectID": "01-basics.html#learning-check-2",
    "href": "01-basics.html#learning-check-2",
    "title": "Introduction to Python",
    "section": "Learning Check #2",
    "text": "Learning Check #2\nWhat is the data type of each of this variable?\na = 50  \nb = \"SMU Libraries\"  \nc = 100.5  \nd = True  \ne = 10 * 2.54  \nf = int(5.5)  \ng = 10 &lt; 15  \nh = len(\"The quick brown fox jumps over the lazy dog\")"
  },
  {
    "objectID": "01-basics.html#arguments-vs-parameters",
    "href": "01-basics.html#arguments-vs-parameters",
    "title": "Introduction to Python",
    "section": "Arguments vs Parameters",
    "text": "Arguments vs Parameters\n\nThere are many built-in function that we can use, one of the common one is round() which will round a float number to the nearest integer.\nSome functions accept arguments, and we put them inside the brackets when we pass it to the function. It’s like telling the function “do what you’re supposed to do with this things I pass to you”.\n\n\nround(3.14)\n\n3\n\n\nformal definition, but often used interchangeably:\n\narguments = the value passed to a function - in this case, 3.14\nparameters = the variable passed to a function"
  },
  {
    "objectID": "01-basics.html#how-do-i-find-out-more-about-a-function",
    "href": "01-basics.html#how-do-i-find-out-more-about-a-function",
    "title": "Introduction to Python",
    "section": "How do I find out more about a function?",
    "text": "How do I find out more about a function?\n\nSome functions can take more than one arguments! we’ve seen this with print() earlier.\nIf you’re not sure what kind of arguments are accepted, etc, use the help() function. This example below should tell you more about round() once executed.\n\n\nhelp(round)\n\nHelp on built-in function round in module builtins:\n\nround(number, ndigits=None)\n    Round a number to a given precision in decimal digits.\n    \n    The return value is an integer if ndigits is omitted or None.  Otherwise\n    the return value has the same type as the number.  ndigits may be negative."
  },
  {
    "objectID": "01-basics.html#more-data-types-structure",
    "href": "01-basics.html#more-data-types-structure",
    "title": "Introduction to Python",
    "section": "More data types / structure",
    "text": "More data types / structure\nOther than the basic 4 types that we learned earlier, Python has more data structures where we can store multiple values in a single variable:\n\nLists: Ordered, mutable (i.e. can be edited) sequences of elements. Examples: [1, 2, 3], ['a', 'b', 'c']\nTuples: Ordered, immutable (i.e. cannot be edited once it is created) sequences of elements. Examples: (1, 2, 3), ('a', 'b', 'c')\nDictionaries (dict): Unordered collections of key-value pairs. Example: {'name': 'John', 'age': 30}\nSets: Unordered collections of unique elements. Example: {1, 2, 3}\n\nWe will not be covering all of the above, only list and dictionaries (for session 4)"
  },
  {
    "objectID": "01-basics.html#when-lists-would-be-useful",
    "href": "01-basics.html#when-lists-would-be-useful",
    "title": "Introduction to Python",
    "section": "When lists would be useful",
    "text": "When lists would be useful\nScenario: We want to track Singapore’s GDP year-over-year (YoY) growth from 2024 to 2018.\n\nA list helps us store multiple years of data in one place, making it efficient.\nWithout a list, we’d need dozens of separate variables for each year, making it harder to analyze trends.\nUsing a list, we can easily manage and analyze the data for all the years together.\n\n\n# growth rates from 2023 Q1 to 2024 Q2\nquarterly_gdp_growth = [-2,-5.8, 2.8, 2.6, 7.3, 1.1, 3.4]\n\nYou can also initialize an empty list to fill later\n\nfuture_growth_rates = []"
  },
  {
    "objectID": "01-basics.html#check-number-of-items-in-a-list",
    "href": "01-basics.html#check-number-of-items-in-a-list",
    "title": "Introduction to Python",
    "section": "Check number of items in a list",
    "text": "Check number of items in a list\nAs a good first step, it’s good to check the number of items you have in your list!\n\nprint('GDP growth rates:', quarterly_gdp_growth)\nprint('Number of quarters:', len(quarterly_gdp_growth))\n\nGDP growth rates: [-2, -5.8, 2.8, 2.6, 7.3, 1.1, 3.4]\nNumber of quarters: 7"
  },
  {
    "objectID": "01-basics.html#retrieve-a-single-item-from-a-list",
    "href": "01-basics.html#retrieve-a-single-item-from-a-list",
    "title": "Introduction to Python",
    "section": "Retrieve a single item from a list",
    "text": "Retrieve a single item from a list\nSometimes you don’t need the entire list. To retrieve a single value from a list, simply specify their index number enclosed in square brackets\n\nRemember that index starts from 0 instead of 1.\nSo if you want to retrieve the fourth item (2021’s growth rate), the index will be 3.\n\n\nprint('GDP growth rate in 2023 Q1 (1st item):', quarterly_gdp_growth[0])\nprint('GDP growth rate in 2024 Q2 (6th item):', quarterly_gdp_growth[5])\n\nGDP growth rate in 2023 Q1 (1st item): -2\nGDP growth rate in 2024 Q2 (6th item): 1.1\n\n\nIf we put an index number that’s larger than actual number of items, python will give us an error!\nquarterly_gdp_growth[10] # This would cause an IndexError"
  },
  {
    "objectID": "01-basics.html#retrieve-multiple-items-from-a-list-the-syntax",
    "href": "01-basics.html#retrieve-multiple-items-from-a-list-the-syntax",
    "title": "Introduction to Python",
    "section": "Retrieve multiple items from a list: the syntax",
    "text": "Retrieve multiple items from a list: the syntax\nSlicing allows you to extract a portion of the list by specifying a range of indices. The basic syntax for slicing is:\nlist_name[start:end:step]\n\nstart is the index where the slice starts (inclusive)\nend is the index where the slice ends (exclusive)\nIf start is omitted, the slice begins from the start of the list\nIf end is omitted, the slice goes to the end of the list\nstep is optional; it determines how many items to skip"
  },
  {
    "objectID": "01-basics.html#retrieve-multiple-items-from-a-list-in-action",
    "href": "01-basics.html#retrieve-multiple-items-from-a-list-in-action",
    "title": "Introduction to Python",
    "section": "Retrieve multiple items from a list: in action",
    "text": "Retrieve multiple items from a list: in action\nSpecifying the start and end:\n\n\nprint('First three quarters:', \nquarterly_gdp_growth[0:3])\n\n\nFirst three quarters: [-2, -5.8, 2.8]\n\n\nOmitting the end index:\n\n\nprint('From Q3 2023 onwards:', \nquarterly_gdp_growth[2:])\n\n\nFrom Q3 2023 onwards: [2.8, 2.6, 7.3, 1.1, 3.4]\n\n\nOmitting the start:\n\n\nprint('First three quarters:', \nquarterly_gdp_growth[:3])\n\n\nFirst three quarters: [-2, -5.8, 2.8]\n\n\nIf we put a negative index, python list will count from the end instead of the beginning!\n\n\nprint('Last three quarters:', \nquarterly_gdp_growth[-3:])\n\n\nLast three quarters: [7.3, 1.1, 3.4]"
  },
  {
    "objectID": "01-basics.html#stepping-value-in-a-list",
    "href": "01-basics.html#stepping-value-in-a-list",
    "title": "Introduction to Python",
    "section": "Stepping value in a list",
    "text": "Stepping value in a list\nYou can also use a step value to skip items!\nIt is particularly useful if you need to reverse a list.\n\nprint('Every other quarter:', quarterly_gdp_growth[::2])\nprint('Quarters in reverse order:', quarterly_gdp_growth[::-1])\n\nEvery other quarter: [-2, 2.8, 7.3, 3.4]\nQuarters in reverse order: [3.4, 1.1, 7.3, 2.6, 2.8, -5.8, -2]"
  },
  {
    "objectID": "01-basics.html#updating-the-value-of-items-inside-a-list",
    "href": "01-basics.html#updating-the-value-of-items-inside-a-list",
    "title": "Introduction to Python",
    "section": "Updating the value of items inside a list",
    "text": "Updating the value of items inside a list\nList values can be replaced by simply assigning a new value to them! Let’s update the growth rate for 2023 Q3 (index 2) with the correct figure.\n\nquarterly_gdp_growth[2] = -2.8\nprint('Updated GDP growth rates:', quarterly_gdp_growth)\n\nUpdated GDP growth rates: [-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4]"
  },
  {
    "objectID": "01-basics.html#appending-items-to-a-list",
    "href": "01-basics.html#appending-items-to-a-list",
    "title": "Introduction to Python",
    "section": "Appending items to a list",
    "text": "Appending items to a list\nLet’s append a new data of 3.2% growth that we get for 2024 Q3 to the list. Appending will put this new item at the end of the list.\n\nprint('GDP growth rates initially:', quarterly_gdp_growth)\nquarterly_gdp_growth.append(3.2)  \nprint('GDP growth rates after adding 2024 Q3 prediction:', quarterly_gdp_growth)\n\nGDP growth rates initially: [-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4]\nGDP growth rates after adding 2024 Q3 prediction: [-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4, 3.2]"
  },
  {
    "objectID": "01-basics.html#adding-data-to-a-specific-position-in-a-list",
    "href": "01-basics.html#adding-data-to-a-specific-position-in-a-list",
    "title": "Introduction to Python",
    "section": "Adding data to a specific position in a list",
    "text": "Adding data to a specific position in a list\nLet’s add data to the start of the list! The data is growth for 2022 Q4, which was 9.4%.\n\nprint('GDP growth rates initially:', quarterly_gdp_growth)\n1quarterly_gdp_growth.insert(0, 9.4)\nprint('GDP growth rates after adding 2022 Q4:', quarterly_gdp_growth)\n\n\n1\n\nThe first parameter is the index position of where we want this new value to be. The second parameter is the actual value we’d like to insert.\n\n\n\n\nGDP growth rates initially: [-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4, 3.2]\nGDP growth rates after adding 2022 Q4: [9.4, -2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4, 3.2]"
  },
  {
    "objectID": "01-basics.html#removing-items-from-a-list",
    "href": "01-basics.html#removing-items-from-a-list",
    "title": "Introduction to Python",
    "section": "Removing items from a list",
    "text": "Removing items from a list\nLet’s remove the two items we added previously!\nThere are two ways to remove items: using del or .pop() method.\n\nprint('GDP growth rates initially:', quarterly_gdp_growth)\n1del quarterly_gdp_growth[0]\n2quarterly_gdp_growth.pop()\nprint('GDP growth rates after removing projection:', quarterly_gdp_growth)\n\n\n1\n\nwith del, you need to specify the index of the items you’d like to remove\n\n2\n\npop() will remove the item at the end of the list.\n\n\n\n\nGDP growth rates initially: [9.4, -2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4, 3.2]\nGDP growth rates after removing projection: [-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4]"
  },
  {
    "objectID": "01-basics.html#calculations-with-list",
    "href": "01-basics.html#calculations-with-list",
    "title": "Introduction to Python",
    "section": "Calculations with List",
    "text": "Calculations with List\nLet’s say we want to calculate the average quarterly gdp growth:\n\ntotal_growth = sum(quarterly_gdp_growth)\naverage_growth = total_growth / len(quarterly_gdp_growth)\nprint(f\"Average quarterly GDP growth: {average_growth:.2f}%\")\n\nAverage quarterly GDP growth: 0.54%"
  },
  {
    "objectID": "01-basics.html#various-data-types-in-a-single-list",
    "href": "01-basics.html#various-data-types-in-a-single-list",
    "title": "Introduction to Python",
    "section": "Various data types in a single list",
    "text": "Various data types in a single list\nYou can include values of different types in a list, though for GDP data we’ll stick to numbers!\n\nmixed_data = [\"2024 growth\", 3.0, \"2023 growth\", 2.7]\nprint(mixed_data)\n\n['2024 growth', 3.0, '2023 growth', 2.7]"
  },
  {
    "objectID": "01-basics.html#learning-check-3",
    "href": "01-basics.html#learning-check-3",
    "title": "Introduction to Python",
    "section": "Learning Check #3",
    "text": "Learning Check #3\nWrite a code to complete the following tasks:\n\nWrite a code to print the growth rate for 2023 Q4 (remember, it’s the 5th item but index 4)\n\n\n\nCode\nprint(quarterly_gdp_growth[4])\n\n\n7.3\n\n\n\nWrite a code to print the growth rates for the first three quarters of 2023\n\n\n\nCode\nprint(quarterly_gdp_growth[0:3])\n\n\n[-2, -5.8, -2.8]\n\n\n\nAdd a projected growth rate of 3.3 and 3.6 the next two quarters at the end of the list\n\n\n\nCode\n# method 1 using insert\nquarterly_gdp_growth.insert(len(quarterly_gdp_growth), 3.3)\n\n# method 2 using append\nquarterly_gdp_growth.append(3.6)\n\nprint(quarterly_gdp_growth)\n\n\n[-2, -5.8, -2.8, 2.6, 7.3, 1.1, 3.4, 3.3, 3.6]"
  },
  {
    "objectID": "01-basics.html#automate-stuff-with-loop",
    "href": "01-basics.html#automate-stuff-with-loop",
    "title": "Introduction to Python",
    "section": "Automate stuff with loop!",
    "text": "Automate stuff with loop!\nScenario: We have Singapore’s Quarterly GDP growth rates from 2023 Q1 to 2024 Q2, and we want to print them in this format: Quarterly GDP growth: 5%\n\n\nManually printing out the items\n\nprint(\"Quarterly GDP growth:\", quarterly_gdp_growth[0], \"%\") \nprint(\"Quarterly GDP growth:\", quarterly_gdp_growth[1], \"%\") \nprint(\"Quarterly GDP growth:\", quarterly_gdp_growth[2], \"%\") \nprint(\"Quarterly GDP growth:\", quarterly_gdp_growth[3], \"%\") \nprint(\"Quarterly GDP growth:\", quarterly_gdp_growth[4], \"%\") \n# and so on...\n# can you imagine doing this for 100++ items?\n\nQuarterly GDP growth: -2 %\nQuarterly GDP growth: -5.8 %\nQuarterly GDP growth: -2.8 %\nQuarterly GDP growth: 2.6 %\nQuarterly GDP growth: 7.3 %\n\n\n\nWith for loop\n\nfor growth in quarterly_gdp_growth: \n    print(\"Quarterly GDP growth:\", growth, \"%\") \n\nQuarterly GDP growth: -2 %\nQuarterly GDP growth: -5.8 %\nQuarterly GDP growth: -2.8 %\nQuarterly GDP growth: 2.6 %\nQuarterly GDP growth: 7.3 %\nQuarterly GDP growth: 1.1 %\nQuarterly GDP growth: 3.4 %\nQuarterly GDP growth: 3.3 %\nQuarterly GDP growth: 3.6 %\n\n\n\nAs you can see, we can achieve the same thing (or more) with less code to type with for loop."
  },
  {
    "objectID": "01-basics.html#anatomy-of-a-loop",
    "href": "01-basics.html#anatomy-of-a-loop",
    "title": "Introduction to Python",
    "section": "Anatomy of a loop",
    "text": "Anatomy of a loop\nAnatomy of loops explained using the example above:\n\n1for growth in quarterly_gdp_growth:\n2    print(\"Quarterly GDP growth:\", growth, \"%\")\n\n\n1\n\ngrowth is the loop variable, representing the value that changes with each iteration of the loop. You can think of it as the “current item” being processed. Meanwhile, quarterly_gdp_growth is the collection that the loop iterates over. The loop statement also ends with a colon :.\n\n2\n\nprint(\"Quarterly GDP growth:\", growth, \"%\") is the body of the loop, specifying the action to take for each item in the collection. The body of the loop must be indented."
  },
  {
    "objectID": "01-basics.html#more-examples-using-range",
    "href": "01-basics.html#more-examples-using-range",
    "title": "Introduction to Python",
    "section": "More examples: using range()",
    "text": "More examples: using range()\nBelow is a loop that will print out numbers from 1 to 6:\n\nfor number in range(1, 7):  # 1 to 6, representing 6 quarters\n    print(\"Quarter\", number)\n\nQuarter 1\nQuarter 2\nQuarter 3\nQuarter 4\nQuarter 5\nQuarter 6"
  },
  {
    "objectID": "01-basics.html#more-examples-using-enumerate",
    "href": "01-basics.html#more-examples-using-enumerate",
    "title": "Introduction to Python",
    "section": "More examples: using enumerate()",
    "text": "More examples: using enumerate()\nWe can use enumerate() to loop not only the items inside a list, but also the index position of each item in the list!\nLet’s say we want to re-format our printout to 1) Quarterly GDP growth: 5%\n\nfor index, item in enumerate(quarterly_gdp_growth):\n    print(f\"{index + 1}) Quarterly GDP growth: {item}%\")\n\n1) Quarterly GDP growth: -2%\n2) Quarterly GDP growth: -5.8%\n3) Quarterly GDP growth: -2.8%\n4) Quarterly GDP growth: 2.6%\n5) Quarterly GDP growth: 7.3%\n6) Quarterly GDP growth: 1.1%\n7) Quarterly GDP growth: 3.4%\n8) Quarterly GDP growth: 3.3%\n9) Quarterly GDP growth: 3.6%"
  },
  {
    "objectID": "01-basics.html#automate-decisions-with-conditionals",
    "href": "01-basics.html#automate-decisions-with-conditionals",
    "title": "Introduction to Python",
    "section": "Automate decisions with conditionals!",
    "text": "Automate decisions with conditionals!\nScenario: We have Singapore’s Quarterly GDP growth rates, and we want to categorize them as “Growth”, “Stable”, or “Decline” based on their values.\n\n\nWithout conditionals and for loops\n\nprint(quarterly_gdp_growth[0], \"% - Category: Decline\")\nprint(quarterly_gdp_growth[1], \"% - Category: Decline\")\nprint(quarterly_gdp_growth[2], \"% - Category: Decline\")\nprint(quarterly_gdp_growth[3], \"% - Category: Growth\")\nprint(quarterly_gdp_growth[4], \"% - Category: Growth\")\n\n-2 % - Category: Decline\n-5.8 % - Category: Decline\n-2.8 % - Category: Decline\n2.6 % - Category: Growth\n7.3 % - Category: Growth\n\n\n\nWith conditionals and for loops\n\nfor growth in quarterly_gdp_growth:\n    if growth &gt; 2:\n        category = \"Growth\"\n    elif -2 &lt;= growth &lt;= 2:\n        category = \"Stable\"\n    else:\n        category = \"Decline\"\n    \n    print(f\"{growth}% - Category: {category}\")\n\n-2% - Category: Stable\n-5.8% - Category: Decline\n-2.8% - Category: Decline\n2.6% - Category: Growth\n7.3% - Category: Growth\n1.1% - Category: Stable\n3.4% - Category: Growth\n3.3% - Category: Growth\n3.6% - Category: Growth"
  },
  {
    "objectID": "01-basics.html#why-conditionals-for-loops-is-great",
    "href": "01-basics.html#why-conditionals-for-loops-is-great",
    "title": "Introduction to Python",
    "section": "Why conditionals + for loops is great",
    "text": "Why conditionals + for loops is great\n\nAutomated categorization based on values - no manual intervention needed!\nEasily adjustable criteria (just change the numbers in the if-elif-else statements)\nWorks for any number of data points - again, no manual intervention needed!\nMakes the code more readable and maintainable\n\nLet’s break down the anatomy of conditionals first!"
  },
  {
    "objectID": "01-basics.html#anatomy-of-conditionals",
    "href": "01-basics.html#anatomy-of-conditionals",
    "title": "Introduction to Python",
    "section": "Anatomy of Conditionals",
    "text": "Anatomy of Conditionals\nAlso called if-else structure, it looks like this at the very basic level:\n\ngdp_growth = 2.5\n\n1if gdp_growth &gt; 0:\n2    print(\"The economy is growing.\")\n3else:\n4    print(\"The economy is not growing.\")\n\n\n1\n\nThe if statement starts with the keyword ‘if’, followed by a condition, and ends with a colon ‘:’\n\n2\n\nThe body of the if statement is indented. This line of code will be run if the condition is fulfilled\n\n3\n\nThe else clause is optional, starts with ‘else’, and ends with a colon ‘:’\n\n4\n\nThe body of the else clause is also indented, and only run if the condition is NOT fulfilled\n\n\n\n\nThe economy is growing."
  },
  {
    "objectID": "01-basics.html#multiple-conditions",
    "href": "01-basics.html#multiple-conditions",
    "title": "Introduction to Python",
    "section": "Multiple conditions",
    "text": "Multiple conditions\nSometimes we have multiple conditions that we want to check! We can use elif (stands for else-if) to add the conditions. You can have multiple elif clauses.\n\ngdp_growth = 0\n\nif gdp_growth &gt; 0:\n    print(\"The economy is growing.\")\nelif gdp_growth == 0:\n    print(\"The economy is stable.\")\nelse:\n    print(\"The economy is shrinking.\")\n\nThe economy is stable."
  },
  {
    "objectID": "01-basics.html#multiple-conditions-with-boolean-operators",
    "href": "01-basics.html#multiple-conditions-with-boolean-operators",
    "title": "Introduction to Python",
    "section": "Multiple conditions with Boolean operators",
    "text": "Multiple conditions with Boolean operators\nIn some cases, we can’t split the conditions among multiple elifs. For example, we may want to check gdp_growth and inflation rate to determine the economic state.\n\ngdp_growth = 1.5\ninflation = 2.0\n\n1if gdp_growth &gt; 0 and inflation &lt; 3:\n    print(\"The economy is in a good state.\")\n2elif gdp_growth &gt; 0 or inflation &lt; 3:\n    print(\"The economy is in a mixed state.\")\nelse:\n    print(\"The economy needs attention.\")\n\n\n1\n\nand requires both conditions to be True\n\n2\n\nor requires at least one condition to be True\n\n\n\n\nThe economy is in a good state."
  },
  {
    "objectID": "01-basics.html#multiple-conditions---order-does-matter",
    "href": "01-basics.html#multiple-conditions---order-does-matter",
    "title": "Introduction to Python",
    "section": "Multiple conditions - Order does matter!",
    "text": "Multiple conditions - Order does matter!\nAssuming variable growth has the value of 10, the conditionals below will give us the wrong result.\n\ngrowth = 10\nif growth &gt; 0:\n    print(f\"{growth}% is a moderate growth\")\nelif growth &gt; 5:  # This will never be reached for growth &gt; 1\n    print(f\"{growth}% is a strong growth\")\nelse:\n    print(f\"{growth}% is a negative growth\")\n\n10% is a moderate growth\n\n\nThis ordering would give the correct result:\n\nif growth &gt; 5:\n    print(f\"{growth}% is strong growth\")\nelif growth &gt; 0:\n    print(f\"{growth}% is moderate growth\")\nelse:\n    print(f\"{growth}% is negative growth\")\n\n10% is strong growth"
  },
  {
    "objectID": "01-basics.html#nested-conditionals",
    "href": "01-basics.html#nested-conditionals",
    "title": "Introduction to Python",
    "section": "Nested conditionals",
    "text": "Nested conditionals\nFor a more complicated conditionals, you can put a conditional inside another! Be careful with indentation to ensure correct nesting!\n\ngdp_growth = 2.5\nunemployment = 4.0\n\n1if gdp_growth &gt; 0:\n2    if unemployment &lt; 5:\n        print(\"Strong economic performance.\")\n    else:\n        print(\"Growing economy, but high unemployment.\")\nelse:\n    print(\"Economic challenges ahead.\")\n\n\n1\n\n“outer” conditional.\n\n2\n\n“inner” conditionals. Note the indent for this statement! This conditional will be run only if the outer conditions are fulfilled.\n\n\n\n\nStrong economic performance."
  },
  {
    "objectID": "01-basics.html#conditionals-and-for-loops-combi",
    "href": "01-basics.html#conditionals-and-for-loops-combi",
    "title": "Introduction to Python",
    "section": "Conditionals and For loops combi",
    "text": "Conditionals and For loops combi\nAs seen from the first example of this section, we can combine for loops with conditionals\n\nfor growth in quarterly_gdp_growth:\n    if growth &gt; 2:\n        category = \"Growth\"\n    elif -2 &lt;= growth &lt;= 2:\n        category = \"Stable\"\n    else:\n        category = \"Decline\"\n    \n    print(f\"{growth}% - Category: {category}\")\n\n-2% - Category: Stable\n-5.8% - Category: Decline\n-2.8% - Category: Decline\n2.6% - Category: Growth\n7.3% - Category: Growth\n1.1% - Category: Stable\n3.4% - Category: Growth\n3.3% - Category: Growth\n3.6% - Category: Growth"
  },
  {
    "objectID": "01-basics.html#conditionals-and-for-loops-combi-counting-occurence",
    "href": "01-basics.html#conditionals-and-for-loops-combi-counting-occurence",
    "title": "Introduction to Python",
    "section": "Conditionals and For loops combi: counting occurence",
    "text": "Conditionals and For loops combi: counting occurence\nOther ways for loops and conditionals can be used is for when we want to count occurence. Let’s say we want to keep track how many growths and contractions have happened for the past quarters.\n\n1growth_periods = 0\ndecline_periods = 0\n\nfor rate in quarterly_gdp_growth:\n    if rate &gt; 0:\n2        growth_periods += 1\n    elif rate &lt; 0:\n        decline_periods += 1\n\nprint(\"Growth periods:\", growth_periods)\nprint(\"Decline periods:\", decline_periods)\n\n\n1\n\nset the counters, one to keep track of growth and the other one to keep track of declines\n\n2\n\nincrease the counters when conditions were met.\n\n\n\n\nGrowth periods: 6\nDecline periods: 3"
  },
  {
    "objectID": "01-basics.html#learning-check-4",
    "href": "01-basics.html#learning-check-4",
    "title": "Introduction to Python",
    "section": "Learning Check #4",
    "text": "Learning Check #4\nWrite a script that identifies the highest and lowest growth quarters (5 mins)\n\n\nCode\n# get the value of the highest and the lowest with max and min\nhighest_growth = max(quarterly_gdp_growth)\nlowest_growth = min(quarterly_gdp_growth)"
  },
  {
    "objectID": "01-basics.html#even-more-data-types",
    "href": "01-basics.html#even-more-data-types",
    "title": "Introduction to Python",
    "section": "Even more data types",
    "text": "Even more data types\nWe will explore these in the upcoming sessions!\n\nDateTime\nNumPy’s Arrays\nPanda’s DataFrame & Time series DataFrame"
  },
  {
    "objectID": "02-numpy.html#recap-from-yesterday",
    "href": "02-numpy.html#recap-from-yesterday",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Recap from yesterday",
    "text": "Recap from yesterday\n\nIntroduction to Visual Studio\nIntroduction to Python\nHandling Lists\nHandling Loops and Conditionals"
  },
  {
    "objectID": "02-numpy.html#overview-for-today",
    "href": "02-numpy.html#overview-for-today",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Overview for today",
    "text": "Overview for today\n\nIntroduction to Jupyter Notebook\nPython libraries: Extending Python’s functionality\nNumPy for more efficient numerical computing\nMatplotlib: Data visualization"
  },
  {
    "objectID": "02-numpy.html#refresher-.py-and-.ipynb",
    "href": "02-numpy.html#refresher-.py-and-.ipynb",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Refresher: .py and .ipynb",
    "text": "Refresher: .py and .ipynb\n\n\nIf it’s a .py file…\n\nFor “production” uses e.g., creating apps, industrial deployments; Executing the file will run all the codes inside the file.\n\nIf it’s a .ipynb file…\n\nGreat for quick experiments or teaching / presentation; Codes will be executed on per-block basis"
  },
  {
    "objectID": "02-numpy.html#creating-new-.ipynb-file",
    "href": "02-numpy.html#creating-new-.ipynb-file",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Creating new .ipynb file",
    "text": "Creating new .ipynb file\n\nMake sure that you have Jupyter extension installed in VS Code\nClick on File &gt; New File... and then Jupyter Notebook. If you don’t see this option, most likely it means you don’t have the Jupyter extension installed"
  },
  {
    "objectID": "02-numpy.html#jupyter-notebook-quick-tour",
    "href": "02-numpy.html#jupyter-notebook-quick-tour",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Jupyter Notebook quick tour",
    "text": "Jupyter Notebook quick tour\n\nMore on Markdown formatting here"
  },
  {
    "objectID": "02-numpy.html#jupyter-notebook-running-a-code-cell",
    "href": "02-numpy.html#jupyter-notebook-running-a-code-cell",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Jupyter notebook: running a code cell",
    "text": "Jupyter notebook: running a code cell\nWhen running a code cell for the first time, you will be prompted to choose the python kernel. Choose the version you want (in our case, version 3.12)\n\nIf you are prompted to install ipykernel, go ahead and install it."
  },
  {
    "objectID": "02-numpy.html#whats-numpy",
    "href": "02-numpy.html#whats-numpy",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "What’s Numpy?",
    "text": "What’s Numpy?\nNumPy is the fundamental package for scientific computing in Python.\nIt is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.1\n\nFaster and more memory-efficient than Python lists\nOptimized for large-scale numerical operations (better than list)\n\nhttps://numpy.org/doc/stable/user/whatisnumpy.html"
  },
  {
    "objectID": "02-numpy.html#whats-a-python-library",
    "href": "02-numpy.html#whats-a-python-library",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "What’s a Python library?",
    "text": "What’s a Python library?\n\nPython libraries or packages are essentially reusable sets of code that can be imported into your environment to extend functionality.\nBefore using them, most libraries must first be installed and then imported. This is how you can install a library:\n\npip install numpy"
  },
  {
    "objectID": "02-numpy.html#library-is-installed-now-what",
    "href": "02-numpy.html#library-is-installed-now-what",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Library is installed, now what?",
    "text": "Library is installed, now what?\n\nAfter it is installed, we have to import them to “activate” it in our notebook so that we can use it!\nNote: some libraries are part of the Python Standard Library, meaning they are already installed and ready to be imported straight away! For example, time library.\n\n\nimport numpy as np # giving numpy a shorter \"nickname\"\nimport time\n\nTo use a function that belongs to a library, we have to call the library name (or the nickname, if we assign one), followed by . and then the function name! e.g. if we want to call array function in numpy:\nnp.array()"
  },
  {
    "objectID": "02-numpy.html#numpy-vs-lists",
    "href": "02-numpy.html#numpy-vs-lists",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy vs Lists",
    "text": "Numpy vs Lists\n\n\nLists\n\ndynamic size upon creation; you can change the size of a list anytime.\nall items inside list can be of different data types.\nnot optimized for scientific/mathematical operations\n\n\nNumPy Arrays\n\nfixed size upon creation; changing the size will create new array and delete the original.\nall items inside arrays must be the same data types.\nfacilitate advanced mathematical and other types of operations on large numbers of data, and thus more efficient.\na lot scientific/mathematical libraries are build on top of numpy (including pandas!)"
  },
  {
    "objectID": "02-numpy.html#numpy-vs-lists-performance-comparison",
    "href": "02-numpy.html#numpy-vs-lists-performance-comparison",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy vs Lists: Performance comparison",
    "text": "Numpy vs Lists: Performance comparison\nImagine we have a million numbers to square. We’ll store them in both a list and an array, then compare their processing speeds.\n\n\nLists\n\nlist_data = list(range(1000000))\n\nstart = time.time()\nlist_result = [x**2 for x in list_data]\nlist_time = time.time() - start\n\nprint(f\"List took {list_time:.4f} seconds to finish the operation.\")\n\nList took 0.0780 seconds to finish the operation.\n\n\n\nNumpy Arrays\n\nnumpy_data = np.arange(1000000)\n\nstart = time.time()\nnumpy_result = numpy_data**2\nnumpy_time = time.time() - start\n\nprint(f\"NumPy took {numpy_time:.4f} seconds to finish the operation.\")\n\nNumPy took 0.0030 seconds to finish the operation."
  },
  {
    "objectID": "02-numpy.html#numpy-vs-lists-sum-and-products",
    "href": "02-numpy.html#numpy-vs-lists-sum-and-products",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy vs Lists: Sum and products",
    "text": "Numpy vs Lists: Sum and products\n\nWhen you add two lists together, the contents will be concatenated\nWhen you do add two arrays together, the contents will be summed\n\n\n\nLists\n\nlist_1 = [1, 2, 3, 4, 5]\nlist_2 = [10, 20, 30, 40, 50]\n\nprint(list_1 + list_2)\n# list_1 * list_2 will give an error\n\n[1, 2, 3, 4, 5, 10, 20, 30, 40, 50]\n\n\n\nNumpy Arrays\n\narray_1 = np.array([1, 2, 3, 4, 5])\narray_2 = np.array([10, 20, 30, 40, 50])\n\nprint(\"Sum:\", array_1 + array_2)\nprint(\"Product:\", array_1 * array_2)\n\nSum: [11 22 33 44 55]\nProduct: [ 10  40  90 160 250]"
  },
  {
    "objectID": "02-numpy.html#numpy-creation-and-operations",
    "href": "02-numpy.html#numpy-creation-and-operations",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy creation and operations",
    "text": "Numpy creation and operations\nwe can use np.arange() to create an array from scratch. We can also create an array from a list using np.array()\nnp.arange creates evenly spaced values within a given interval:\n\nrange_array = np.arange(0, 10, 0.5)\nprint(\"Range array:\", range_array)\n\nRange array: [0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\n\n\nnp.array will transform a list (denoted in square brackets) to array:\n\nlist_array = np.array([1, 2, 3, 4, 5])\nprint(\"NumPy array:\", list_array)\n\nNumPy array: [1 2 3 4 5]"
  },
  {
    "objectID": "02-numpy.html#numpy-operations",
    "href": "02-numpy.html#numpy-operations",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy operations",
    "text": "Numpy operations\nMost operations we perform on lists can also be done with arrays, including:\n\nSlicing\nIndexing\nSorting\nCreating copies or views (with important differences between them!)\n\nLet’s try these! Also, you can refer to this handy Numpy cheat sheet by Datacamp"
  },
  {
    "objectID": "02-numpy.html#indexing-and-slicing",
    "href": "02-numpy.html#indexing-and-slicing",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Indexing and Slicing",
    "text": "Indexing and Slicing\nfor indexing and slicing, it’s pretty much the same as list!\n\nprint(\"Original array:\", range_array)\nprint(\"First element:\", range_array[0])\nprint(\"Last element:\", range_array[-1])\nprint(\"Slicing (elements 3 to 7):\", range_array[2:7])\nrange_array[0] = 99\nprint(\"Update value of first element:\", range_array[0])\nprint(\"Sorting array:\", np.sort(range_array))\n\nOriginal array: [0.  0.5 1.  1.5 2.  2.5 3.  3.5 4.  4.5 5.  5.5 6.  6.5 7.  7.5 8.  8.5\n 9.  9.5]\nFirst element: 0.0\nLast element: 9.5\nSlicing (elements 3 to 7): [1.  1.5 2.  2.5 3. ]\nUpdate value of first element: 99.0\nSorting array: [ 0.5  1.   1.5  2.   2.5  3.   3.5  4.   4.5  5.   5.5  6.   6.5  7.\n  7.5  8.   8.5  9.   9.5 99. ]"
  },
  {
    "objectID": "02-numpy.html#copy-vs-views",
    "href": "02-numpy.html#copy-vs-views",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Copy vs Views",
    "text": "Copy vs Views\nLet’s create 3 arrays:\n\n\noriginal = np.array([1, 2, 3, 4, 5])\nprint(\"Original array:\", original)\n\nview = original.view()\nprint(\"View:\", view)\n\ncopy = original.copy()\nprint(\"Copy:\", copy)\n\n\nOriginal array: [1 2 3 4 5]\nView: [1 2 3 4 5]\nCopy: [1 2 3 4 5]"
  },
  {
    "objectID": "02-numpy.html#copy-vs-views-in-action",
    "href": "02-numpy.html#copy-vs-views-in-action",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Copy vs Views: in action",
    "text": "Copy vs Views: in action\n\nChanges in original will be reflected in View and vice versa\nChanges in original will NOT be reflected in copy\n\n\n\noriginal[0] = 99\nprint(\"\\nAfter modifying the original array:\")\nprint(\"Original array:\", original)\nprint(\"View now:\", view)  # reflects the changes\nprint(\"Copy now:\", copy)  # remains unchanged\n\n# Modify the view\nview[1] = 100\nprint(\"\\nAfter modifying the view:\")\nprint(\"Original array:\", original)  # affected\nprint(\"View now:\", view)\nprint(\"Copy now:\", copy)  # remains unchanged\n\n# Modify the copy\ncopy[2] = 200\nprint(\"\\nAfter modifying the copy:\")\nprint(\"Original array:\", original)  # not affected\nprint(\"View now:\", view)  # not affected\nprint(\"Copy now:\", copy)\n\n\n\nAfter modifying the original array:\nOriginal array: [99  2  3  4  5]\nView now: [99  2  3  4  5]\nCopy now: [1 2 3 4 5]\n\nAfter modifying the view:\nOriginal array: [ 99 100   3   4   5]\nView now: [ 99 100   3   4   5]\nCopy now: [1 2 3 4 5]\n\nAfter modifying the copy:\nOriginal array: [ 99 100   3   4   5]\nView now: [ 99 100   3   4   5]\nCopy now: [  1   2 200   4   5]"
  },
  {
    "objectID": "02-numpy.html#learning-check-1",
    "href": "02-numpy.html#learning-check-1",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Learning Check #1",
    "text": "Learning Check #1\nCreate two arrays called odd_numbers and even_numbers that only contains odd numbers and even numbers from 1 to 20 respectively.\n\n\nCode\nodd_numbers = np.arange(1, 21, 2)\neven_numbers = np.arange(0, 21, 2)\nprint(\"Odd numbers:\", odd_numbers)\nprint(\"Even numbers:\", even_numbers)\n\n\nOdd numbers: [ 1  3  5  7  9 11 13 15 17 19]\nEven numbers: [ 0  2  4  6  8 10 12 14 16 18 20]"
  },
  {
    "objectID": "02-numpy.html#array-can-contain-columns-and-rows-too",
    "href": "02-numpy.html#array-can-contain-columns-and-rows-too",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Array can contain columns and rows too!",
    "text": "Array can contain columns and rows too!\n\narray_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(array_2d)\nprint(\"Shape of the array:\", array_2d.shape)\nprint(\"Size of the array:\", array_2d.size)\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\nShape of the array: (3, 3)\nSize of the array: 9"
  },
  {
    "objectID": "02-numpy.html#indices-in-a-2d-array",
    "href": "02-numpy.html#indices-in-a-2d-array",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Indices in a 2D array",
    "text": "Indices in a 2D array\n\n\nAlternative way to “count” the indices is that we move from “outer” to “inner”.\ne.g. the value 4 is located inside the 2nd sub-list. and in this sub-list, it is located on the 1st index, hence [1, 0] (remember to minus 1, as indexing in python starts from 0)"
  },
  {
    "objectID": "02-numpy.html#loading-from-a-csv-into-a-2d-array",
    "href": "02-numpy.html#loading-from-a-csv-into-a-2d-array",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Loading from a CSV into a 2D array",
    "text": "Loading from a CSV into a 2D array\nLet’s load our data sg-gdp.csv into a 2D array!\nIn this CSV:\n\nThe rows represent 7 different sectors\nThe columns represent the quarters from 2023 Q4, dating back all the way to 2019 Q1.\nEach cell contains the GDP growth of that sector for that quarter, compared to previous year’s quarters.\n\n\ngdp_data = np.loadtxt('data/sg-gdp.csv', delimiter=',', dtype=\"float16\")\nnp.set_printoptions(suppress=True)\n\nprint(\"GDP data\")\nprint(gdp_data)\nprint(\"GDP data shape:\", gdp_data.shape)\n\n\nRemember, the shape will be printed as (row, column)."
  },
  {
    "objectID": "02-numpy.html#loading-from-a-csv-into-a-2d-array-output",
    "href": "02-numpy.html#loading-from-a-csv-into-a-2d-array-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Loading from a CSV into a 2D array",
    "text": "Loading from a CSV into a 2D array\n\nGDP data\n[[  2.6  -2.8  -5.8  -2.    9.4  17.5  24.5  20.9  22.9  23.1  31.6   7.7\n   -2.8  -7.4 -14.4  -0.4  -1.8   0.3   2.1   4.3]\n [ -2.   -7.6 -12.7  -7.2   7.1   9.6  20.9  24.1  27.7  29.8  43.3   8.3\n   -6.5  -9.5 -19.3  -2.1 -16.2  -6.3  -0.1   8. ]\n [ -5.5 -12.3 -18.2 -11.9   4.2   7.6  21.9  25.3  27.   25.4  37.7  11.4\n   -3.2  -2.7 -12.6  -1.2 -19.3  -7.9  -0.5   9.3]\n [ 11.6  11.3  15.5  15.6  17.6  17.7  12.6  16.   45.1 106.3 174.   -6.1\n  -29.2 -52.9 -66.1 -10.1  -1.8   0.2   3.    3.4]\n [ 12.9  25.   27.3  21.6  28.4  27.6  22.8  24.7   3.9   0.3  -1.3  -1.1\n   10.1  -1.2   5.3  10.1  -0.5   3.3  -2.5   1.3]\n [  7.4   9.7   4.4   7.6   2.7   1.5   0.7   1.9   8.   11.   34.3   4.8\n    5.4  -7.1 -15.5  -1.5   4.7  10.5   5.3  11.8]\n [  3.   -2.7  -4.7  -1.5  10.9  21.7  27.9  21.9  22.8  21.6  25.7   7.3\n   -2.2  -6.8 -10.8   0.3   3.4   2.5   3.6   3.9]]\nGDP data shape: (7, 20)"
  },
  {
    "objectID": "02-numpy.html#d-array-operations",
    "href": "02-numpy.html#d-array-operations",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "2D array operations",
    "text": "2D array operations\nLet’s see if we can complete the following tasks:\n\nFind out the mean, standard deviation, max, and min values.\nFind the mean for each quarter (column-wise operation)\nFind the mean for each sector (row-wise operation)\nTranspose the array\nRetrieve all the negative values.\nCalculate the changes every quarter for Sector 1."
  },
  {
    "objectID": "02-numpy.html#task-1-find-out-the-mean-standard-deviation-max-and-mean-values.",
    "href": "02-numpy.html#task-1-find-out-the-mean-standard-deviation-max-and-mean-values.",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Task 1: Find out the mean, standard deviation, max, and mean values.",
    "text": "Task 1: Find out the mean, standard deviation, max, and mean values.\n\nprint(\"Mean of GDP data:\", np.mean(gdp_data))\nprint(\"Standard deviation of GDP data:\", np.std(gdp_data))\nprint(\"Maximum value in GDP data:\", np.amax(gdp_data))\nprint(\"Minimum value in GDP data:\", np.amin(gdp_data))\n\nMean of GDP data: 7.504\nStandard deviation of GDP data: inf\nMaximum value in GDP data: 174.0\nMinimum value in GDP data: -66.1\n\n\n\n\n\n\n\n\n\nDid you get inf result?\n\n\nYou may get inf result in one of your calculation. A possible cause is because when we create the array, we declared the data type (dtype) as float16. This means the array uses 16 bits (2 bytes) for each number, which translates to lower precision (only ~3 decimals), but lower memory usage and storage.\nBy default, numpy will use float64 data type which can gives us higher precision. Changing the dtype to float64 should fix this issue."
  },
  {
    "objectID": "02-numpy.html#axis-operations",
    "href": "02-numpy.html#axis-operations",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Axis Operations",
    "text": "Axis Operations"
  },
  {
    "objectID": "02-numpy.html#task-2-3-find-the-mean-for-each-quarter-and-each-sector",
    "href": "02-numpy.html#task-2-3-find-the-mean-for-each-quarter-and-each-sector",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Task 2 & 3: Find the mean for each quarter and each sector",
    "text": "Task 2 & 3: Find the mean for each quarter and each sector\n\nprint(\"Mean of each quarter:\", np.mean(gdp_data, axis=0))\nprint(\"Mean of each sector:\", np.mean(gdp_data, axis=1))\n\nMean of each quarter: [  4.285    2.943    0.827    3.172   11.47    14.74    18.77    19.27\n  22.48    31.08    49.34     4.613   -4.06   -12.516  -19.06    -0.7\n  -4.5      0.3716   1.558    6.    ]\nMean of each sector: [ 6.477  4.465  3.725 14.18  10.9    5.38   7.39 ]"
  },
  {
    "objectID": "02-numpy.html#task-4-transpose-the-array",
    "href": "02-numpy.html#task-4-transpose-the-array",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Task 4: Transpose the array",
    "text": "Task 4: Transpose the array\n\ntransposed_gdp = np.transpose(gdp_data)\nprint(\"Transposed GDP data shape:\", transposed_gdp.shape)\n\nTransposed GDP data shape: (20, 7)\n\n\nAlternatively, you can also do it this way:\n\ntransposed = gdp_data.T\nprint(transposed)\n\n[[  2.6  -2.   -5.5  11.6  12.9   7.4   3. ]\n [ -2.8  -7.6 -12.3  11.3  25.    9.7  -2.7]\n [ -5.8 -12.7 -18.2  15.5  27.3   4.4  -4.7]\n [ -2.   -7.2 -11.9  15.6  21.6   7.6  -1.5]\n [  9.4   7.1   4.2  17.6  28.4   2.7  10.9]\n [ 17.5   9.6   7.6  17.7  27.6   1.5  21.7]\n [ 24.5  20.9  21.9  12.6  22.8   0.7  27.9]\n [ 20.9  24.1  25.3  16.   24.7   1.9  21.9]\n [ 22.9  27.7  27.   45.1   3.9   8.   22.8]\n [ 23.1  29.8  25.4 106.3   0.3  11.   21.6]\n [ 31.6  43.3  37.7 174.   -1.3  34.3  25.7]\n [  7.7   8.3  11.4  -6.1  -1.1   4.8   7.3]\n [ -2.8  -6.5  -3.2 -29.2  10.1   5.4  -2.2]\n [ -7.4  -9.5  -2.7 -52.9  -1.2  -7.1  -6.8]\n [-14.4 -19.3 -12.6 -66.1   5.3 -15.5 -10.8]\n [ -0.4  -2.1  -1.2 -10.1  10.1  -1.5   0.3]\n [ -1.8 -16.2 -19.3  -1.8  -0.5   4.7   3.4]\n [  0.3  -6.3  -7.9   0.2   3.3  10.5   2.5]\n [  2.1  -0.1  -0.5   3.   -2.5   5.3   3.6]\n [  4.3   8.    9.3   3.4   1.3  11.8   3.9]]"
  },
  {
    "objectID": "02-numpy.html#task-5-retrieve-all-the-negative-values.",
    "href": "02-numpy.html#task-5-retrieve-all-the-negative-values.",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Task 5: Retrieve all the negative values.",
    "text": "Task 5: Retrieve all the negative values.\n\nnegative_growth = gdp_data &lt; 0  \nprint(\"negative growth array:\", negative_growth)\nprint(\"use the above array to retrieve items whose position is TRUE:\\n\", gdp_data[negative_growth])\n\nnegative growth array: [[False  True  True  True False False False False False False False False\n   True  True  True  True  True False False False]\n [ True  True  True  True False False False False False False False False\n   True  True  True  True  True  True  True False]\n [ True  True  True  True False False False False False False False False\n   True  True  True  True  True  True  True False]\n [False False False False False False False False False False False  True\n   True  True  True  True  True False False False]\n [False False False False False False False False False False  True  True\n  False  True False False  True False  True False]\n [False False False False False False False False False False False False\n  False  True  True  True False False False False]\n [False  True  True  True False False False False False False False False\n   True  True  True False False False False False]]\nuse the above array to retrieve items whose position is TRUE:\n [ -2.8  -5.8  -2.   -2.8  -7.4 -14.4  -0.4  -1.8  -2.   -7.6 -12.7  -7.2\n  -6.5  -9.5 -19.3  -2.1 -16.2  -6.3  -0.1  -5.5 -12.3 -18.2 -11.9  -3.2\n  -2.7 -12.6  -1.2 -19.3  -7.9  -0.5  -6.1 -29.2 -52.9 -66.1 -10.1  -1.8\n  -1.3  -1.1  -1.2  -0.5  -2.5  -7.1 -15.5  -1.5  -2.7  -4.7  -1.5  -2.2\n  -6.8 -10.8]"
  },
  {
    "objectID": "02-numpy.html#task-6-calculate-the-changes-every-quarter-for-sector-1.",
    "href": "02-numpy.html#task-6-calculate-the-changes-every-quarter-for-sector-1.",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Task 6: Calculate the changes every quarter for Sector 1.",
    "text": "Task 6: Calculate the changes every quarter for Sector 1.\nThe gdp_data is longitudinal, with each row representing observations for a specific sector over time. This makes growth and contraction trends meaningful to analyze. To calculate changes in the data using NumPy, we can use the numpy.diff() function, which computes the differences between successive values in an array.\n\nsector1_array = gdp_data[0, :] # first row, all columns\nprint(\"sector1_array:\", sector1_array)\n\nsector1_changes = np.diff(sector1_array)\nprint(\"\\nsector1_changes:\", sector1_changes)\n\nsector1_array: [  2.6  -2.8  -5.8  -2.    9.4  17.5  24.5  20.9  22.9  23.1  31.6   7.7\n  -2.8  -7.4 -14.4  -0.4  -1.8   0.3   2.1   4.3]\n\nsector1_changes: [ -5.4     -3.       3.8     11.4      8.1      7.      -3.594    2.\n   0.1875   8.5    -23.89   -10.5     -4.598   -7.      14.      -1.4\n   2.1      1.8      2.201 ]"
  },
  {
    "objectID": "02-numpy.html#numpy-financial",
    "href": "02-numpy.html#numpy-financial",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Numpy Financial",
    "text": "Numpy Financial\nThe numpy-financial package is a collection of elementary financial functions. It’s a relatively tiny package, but useful if you need to do some financial calculations.\n\nCheck out the full documentation here!\nInstall numpy financial\npip install numpy-financial\nImport it to your notebook to “toggle it on”\n\nimport numpy_financial as npf"
  },
  {
    "objectID": "02-numpy.html#calculating-future-value",
    "href": "02-numpy.html#calculating-future-value",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Calculating future value",
    "text": "Calculating future value\nCalculate the future value of $1000 invested for 3 years at a 5.0% average annual rate of return.\n\nprint(npf.fv(rate=0.05, nper=3, pmt=0, pv=-1000))\n\n1157.6250000000002\n\n\nBy convention, the negative sign represents cash flow out (i.e. money not available today)."
  },
  {
    "objectID": "02-numpy.html#calculatine-number-of-payment-period",
    "href": "02-numpy.html#calculatine-number-of-payment-period",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Calculatine number of payment period",
    "text": "Calculatine number of payment period\nYou have a loan of 10,000 SGD at 9% annual interest. How long would it take to pay-off the load if your monthly payment is at 750?\n\nprint(npf.nper(0.09/12, -750, 10000))\n# divided by 12, because the interest is annual but the payment is monthly\n\n14.100683407655323"
  },
  {
    "objectID": "02-numpy.html#learning-check-2",
    "href": "02-numpy.html#learning-check-2",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Learning Check #2",
    "text": "Learning Check #2\n\nCalculate the changes for each quarter for all sector. Save this into an array called sector_changes.\nAfterwards, find the largest changes in sector_changes.\n\n\n\nCode\nsector_changes = np.diff(gdp_data)\nprint(\"sector_changes:\", sector_changes)\nprint(\"\\nsector_changes shape:\", sector_changes.shape)\n\nprint(\"\\nLargest change:\", np.amax(sector_changes))"
  },
  {
    "objectID": "02-numpy.html#learning-check-2-output",
    "href": "02-numpy.html#learning-check-2-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Learning Check #2",
    "text": "Learning Check #2\n\nsector_changes: [[  -5.4       -3.         3.8       11.4        8.1        7.\n    -3.594      2.         0.1875     8.5      -23.89     -10.5\n    -4.598     -7.        14.        -1.4        2.1        1.8\n     2.201  ]\n [  -5.6       -5.1        5.504     14.3        2.5       11.305\n     3.188      3.61       2.094     13.516    -35.       -14.8\n    -3.        -9.8       17.2      -14.1        9.91       6.2\n     8.1    ]\n [  -6.797     -5.906      6.305     16.1        3.402     14.305\n     3.39       1.703     -1.594     12.28     -26.28     -14.59\n     0.5       -9.91      11.4      -18.1       11.4        7.4\n     9.8    ]\n [  -0.3047     4.203      0.10156    1.992      0.1094    -5.1\n     3.398     29.1       61.22      67.7     -180.1      -23.1\n   -23.7      -13.22      56.03       8.305      2.         2.8\n     0.4004 ]\n [  12.1        2.297     -5.703      6.812     -0.8125    -4.797\n     1.906    -20.8       -3.6       -1.6        0.2002    11.2\n   -11.305      6.5        4.8      -10.6        3.8       -5.8\n     3.8    ]\n [   2.305     -5.305      3.203     -4.902     -1.199     -0.8\n     1.2        6.1        3.        23.31     -29.52       0.5977\n   -12.5       -8.4       14.         6.2        5.8       -5.2\n     6.496  ]\n [  -5.7       -2.         3.2       12.4       10.805      6.203\n    -6.         0.8906    -1.203      4.11     -18.4       -9.5\n    -4.6       -3.996     11.09       3.1       -0.9004     1.1\n     0.3008 ]]\n\nsector_changes shape: (7, 19)\n\nLargest change: 67.7"
  },
  {
    "objectID": "02-numpy.html#visualization-libraries-matplotlib-and-seaborn",
    "href": "02-numpy.html#visualization-libraries-matplotlib-and-seaborn",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Visualization libraries: Matplotlib and Seaborn",
    "text": "Visualization libraries: Matplotlib and Seaborn\nThere are multiple visualization libraries for python. We will try out Matplotlib and Seaborn (for next session)\nPrimary differences between the two:\n\n\nMatplotlib\n\nA foundational Python library for static, interactive, and animated visualizations.\nHighly customizable, offering full control over plot elements (axes, ticks, legends).\nSupports a wide range of plots, from simple line charts to complex 3D visualizations and heatmaps.\nCan be challenging for beginners due to its flexibility.\nIdeal for precise control and building complex plots.\n\n\nSeaborn\n\nBuilt on Matplotlib to simplify statistical visualization with attractive designs.\nOffers high-level abstractions for complex plots (e.g., pair plots, heatmaps) with minimal effort.\nSupports visualizing variable relationships and statistical summaries (e.g., regression, categorical plots).\nEasier for beginners to create high-quality visuals quickly.\nBest for data exploration and statistical analysis with minimal setup."
  },
  {
    "objectID": "02-numpy.html#refresher-data-types-in-social-sciences-and-economics-research",
    "href": "02-numpy.html#refresher-data-types-in-social-sciences-and-economics-research",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Refresher: Data types in social sciences and economics research",
    "text": "Refresher: Data types in social sciences and economics research\n\n\nNon-Continuous Data\n\nNominal/Categorical: Non-ordered, non-numerical data, used to represent qualitative attribute.\nOrdinal: Ordered non-numerical data.\nDiscrete: Numerical data that can only take specific value (usually integers)\nBinary: Nominal data with only two possible outcome.\n\n\nContinuous Data\n\nInterval: Numerical data that can take any value within a range. It does not have a “true zero”.\nRatio: Numerical data that can take any value within a range. it has a “true zero”."
  },
  {
    "objectID": "02-numpy.html#chart-types-and-their-purposes",
    "href": "02-numpy.html#chart-types-and-their-purposes",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Chart types and their purposes",
    "text": "Chart types and their purposes\n\nBar charts: Comparing categories\nLine charts: Trends or progress over time\nScatter plots: Relationships between (continuous) variables\nPie charts: Parts of a whole\n\nDepending on who you ask, some may argue that percent barchart is better at this.\n\nBox plots: Distribution and outliers"
  },
  {
    "objectID": "02-numpy.html#anatomy-of-a-matplotlib-graph",
    "href": "02-numpy.html#anatomy-of-a-matplotlib-graph",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Anatomy of a matplotlib graph",
    "text": "Anatomy of a matplotlib graph\n\n\n\n\nUseful resources:\n\nMatplotlib cheatsheets - This is more beginner-friendly\nQuick start guide\nPython Graph Gallery"
  },
  {
    "objectID": "02-numpy.html#matplotlib-getting-started",
    "href": "02-numpy.html#matplotlib-getting-started",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Matplotlib: Getting started",
    "text": "Matplotlib: Getting started\nAs with the other libraries, let’s install the library and then import it.\npip install matplotlib\nImport the library and give it a nickname called plt.\n\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "02-numpy.html#matplotlib-simple-lineplot",
    "href": "02-numpy.html#matplotlib-simple-lineplot",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Matplotlib: Simple Lineplot",
    "text": "Matplotlib: Simple Lineplot\nLet’s visualize the content of gdp_data.\n\n1plt.plot(gdp_data)\n2plt.xlabel('Quarters')\n3plt.ylabel('Sectors')\n4plt.title('Sectors Growth over Quarters')\n5plt.grid()\n6plt.show()\n\n\n1\n\nThe plot function here will draw a line chart\n\n2\n\nLabel the x axis\n\n3\n\nLabel the y axis\n\n4\n\nGive the graph a title\n\n5\n\nTurn on the grid lines\n\n6\n\nShow the plot!"
  },
  {
    "objectID": "02-numpy.html#matplotlib-simple-lineplot-output",
    "href": "02-numpy.html#matplotlib-simple-lineplot-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Matplotlib: Simple Lineplot",
    "text": "Matplotlib: Simple Lineplot"
  },
  {
    "objectID": "02-numpy.html#something-not-quite-right",
    "href": "02-numpy.html#something-not-quite-right",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Something not quite right…",
    "text": "Something not quite right…\n\nIt seems like it’s trying to plot the differences between sectors instead of growth over each sectors.\nThis is because of the way our data is structured: rows representing sectors and columns representing quarters. The rows info is passed to the X coord and the columns are passed to Y coord.\nWe can fix this by transposing the table, so that the rows represent quarters and columns represent sectors.\n\n\ntransposed = gdp_data.T\nprint(transposed)"
  },
  {
    "objectID": "02-numpy.html#something-not-quite-right-output",
    "href": "02-numpy.html#something-not-quite-right-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Something not quite right…",
    "text": "Something not quite right…\n\n[[  2.6  -2.   -5.5  11.6  12.9   7.4   3. ]\n [ -2.8  -7.6 -12.3  11.3  25.    9.7  -2.7]\n [ -5.8 -12.7 -18.2  15.5  27.3   4.4  -4.7]\n [ -2.   -7.2 -11.9  15.6  21.6   7.6  -1.5]\n [  9.4   7.1   4.2  17.6  28.4   2.7  10.9]\n [ 17.5   9.6   7.6  17.7  27.6   1.5  21.7]\n [ 24.5  20.9  21.9  12.6  22.8   0.7  27.9]\n [ 20.9  24.1  25.3  16.   24.7   1.9  21.9]\n [ 22.9  27.7  27.   45.1   3.9   8.   22.8]\n [ 23.1  29.8  25.4 106.3   0.3  11.   21.6]\n [ 31.6  43.3  37.7 174.   -1.3  34.3  25.7]\n [  7.7   8.3  11.4  -6.1  -1.1   4.8   7.3]\n [ -2.8  -6.5  -3.2 -29.2  10.1   5.4  -2.2]\n [ -7.4  -9.5  -2.7 -52.9  -1.2  -7.1  -6.8]\n [-14.4 -19.3 -12.6 -66.1   5.3 -15.5 -10.8]\n [ -0.4  -2.1  -1.2 -10.1  10.1  -1.5   0.3]\n [ -1.8 -16.2 -19.3  -1.8  -0.5   4.7   3.4]\n [  0.3  -6.3  -7.9   0.2   3.3  10.5   2.5]\n [  2.1  -0.1  -0.5   3.   -2.5   5.3   3.6]\n [  4.3   8.    9.3   3.4   1.3  11.8   3.9]]"
  },
  {
    "objectID": "02-numpy.html#visualize-the-transposed-data",
    "href": "02-numpy.html#visualize-the-transposed-data",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Visualize the transposed data",
    "text": "Visualize the transposed data\nSame code, but this time we pass in the transposed data.\n\n1plt.plot(transposed)\n2plt.xlabel('Quarters')\n3plt.ylabel('Sectors')\n4plt.title('Sectors Growth over Quarters')\n5plt.grid()\n6plt.show()\n\n\n1\n\nPassing in the transposed version\n\n2\n\nLabel the x axis\n\n3\n\nLabel the y axis\n\n4\n\nGive the graph a title\n\n5\n\nTurn on the grid lines\n\n6\n\nShow the plot!"
  },
  {
    "objectID": "02-numpy.html#visualize-the-transposed-data-output",
    "href": "02-numpy.html#visualize-the-transposed-data-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Visualize the transposed data",
    "text": "Visualize the transposed data"
  },
  {
    "objectID": "02-numpy.html#fixing-the-x-axis-labels",
    "href": "02-numpy.html#fixing-the-x-axis-labels",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Fixing the X-axis labels",
    "text": "Fixing the X-axis labels\nIt is still not very readable, so let’s give it proper x-axis labeling!\n\nquarters = ['2019 Q1', '2019 Q2', '2019 Q3', '2019 Q4', '2020 Q1', '2020 Q2', '2020 Q3', \n'2020 Q4',  '2021 Q1', '2021 Q2', '2021 Q3', '2021 Q4', '2022 Q1', '2022 Q2', '2022 Q3', \n1'2022 Q4',  '2023 Q1', '2023 Q2', '2023 Q3', '2023 Q4']\n\n2plt.plot(transposed)\n3plt.xticks(ticks=range(len(quarters)),\n           labels=quarters,\n           rotation=45,\n           ha=\"right\")\nplt.xlabel('Quarters') \nplt.ylabel('Growth and Contractions') \nplt.title('Growth and Contractions over Quarters') \n4plt.tight_layout()\n\nplt.grid() \nplt.show() \n\n\n1\n\nCreate a list of labels that we want to put\n\n2\n\nStill using the transposed array\n\n3\n\nSet the labels. In this lines of code, we tell matplotlib how many labels are there, what are the labels, the rotation of the labels, and the horizontal align.\n\n4\n\nThis will get rid of the extra margins on the sides"
  },
  {
    "objectID": "02-numpy.html#fixing-the-x-axis-labels-output",
    "href": "02-numpy.html#fixing-the-x-axis-labels-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Fixing the X-axis labels",
    "text": "Fixing the X-axis labels"
  },
  {
    "objectID": "02-numpy.html#adding-individual-labels",
    "href": "02-numpy.html#adding-individual-labels",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Adding individual labels",
    "text": "Adding individual labels\nWe can utilize the for loop to add plot the lines and label them one by one.\n\n1for sector_num in range(7):\n5    print(\"plotting sector_num:\", sector_num)\n2    plt.plot(transposed[:, sector_num],\n3    label=\"Sector \" + str(sector_num))\n\n4plt.legend()\n\nplt.xticks(ticks=range(len(quarters)), labels=quarters, rotation=45, ha=\"right\") \nplt.tight_layout()\nplt.grid() \nplt.show() \n\n\n1\n\nHere, we set the loop to run 7 times since we have seven sector. Throughout the loop, sector_num value will change from 0 to 6\n\n2\n\nPutting this here so that we know when a sector is being plotted.\n\n3\n\nPlot the current sector. [:, sector_num] can be read as “all rows, in the sector_num column”\n\n4\n\nlabel each line plot with the sector number.\n\n5\n\nToggle the legend so that all the labels are visible ."
  },
  {
    "objectID": "02-numpy.html#adding-individual-labels-output",
    "href": "02-numpy.html#adding-individual-labels-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Adding individual labels",
    "text": "Adding individual labels\n\nplotting sector_num: 0\nplotting sector_num: 1\nplotting sector_num: 2\nplotting sector_num: 3\nplotting sector_num: 4\nplotting sector_num: 5\nplotting sector_num: 6"
  },
  {
    "objectID": "02-numpy.html#matplotlib-histogram",
    "href": "02-numpy.html#matplotlib-histogram",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Matplotlib: Histogram",
    "text": "Matplotlib: Histogram\nLet’s see if there’s any outlier growths or contractions on each sectors over the quarters! Histogram is the best visualization for this purpose.\n\nplt.boxplot(transposed)\n\nplt.xlabel('Sectors') \nplt.ylabel('Growth and Contractions') \nplt.title('Growth and Contractions for all sectors') \n\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "02-numpy.html#matplotlib-histogram-output",
    "href": "02-numpy.html#matplotlib-histogram-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Matplotlib: Histogram",
    "text": "Matplotlib: Histogram"
  },
  {
    "objectID": "02-numpy.html#learning-check-3",
    "href": "02-numpy.html#learning-check-3",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Learning Check #3",
    "text": "Learning Check #3\nUsing the sg-gdp.csv data loaded into a NumPy array:\n\nCreate a line plot showing the GDP growth over time for the first two sectors only\nAdd appropriate labels, a title, and a legend to the plot.\n\n\n\nCode\ntwo_sectors = gdp_data[:2, :] #[first two rows, all columns]\nsector_number = 1 \nquarters = ['2019 Q1', '2019 Q2', '2019 Q3', '2019 Q4', '2020 Q1', '2020 Q2', '2020 Q3', \n'2020 Q4',  '2021 Q1', '2021 Q2', '2021 Q3', '2021 Q4', '2022 Q1', '2022 Q2', '2022 Q3', \n'2022 Q4',  '2023 Q1', '2023 Q2', '2023 Q3', '2023 Q4']\nfor sector in two_sectors:\n    plt.plot(sector, label = \"Sector \" + str(sector_number))\n    sector_number = sector_number + 1 #increase sector number by 1\n\nplt.xticks(ticks=range(len(quarters)), labels=quarters, rotation=45, ha=\"right\") \nplt.legend()\nplt.grid()\nplt.show()"
  },
  {
    "objectID": "02-numpy.html#learning-check-3-output",
    "href": "02-numpy.html#learning-check-3-output",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Learning Check #3",
    "text": "Learning Check #3"
  },
  {
    "objectID": "04-apis.html#recap-from-yesterday",
    "href": "04-apis.html#recap-from-yesterday",
    "title": "Introduction to APIs",
    "section": "Recap from yesterday",
    "text": "Recap from yesterday\n\nIntroduction to Pandas dataframe\nDatetime in Python and Time Series with Pandas\nAnalyzing and visualizing Time Series dataframe"
  },
  {
    "objectID": "04-apis.html#overview-for-today",
    "href": "04-apis.html#overview-for-today",
    "title": "Introduction to APIs",
    "section": "Overview for today",
    "text": "Overview for today\n\nIntroduction to FRED API\nPresenting with .ipynb\nYour turn: Select an indicator, analyze it, visualize it, and present it to the class!"
  },
  {
    "objectID": "04-apis.html#what-is-it",
    "href": "04-apis.html#what-is-it",
    "title": "Introduction to APIs",
    "section": "What is it?",
    "text": "What is it?"
  },
  {
    "objectID": "04-apis.html#how-does-it-work",
    "href": "04-apis.html#how-does-it-work",
    "title": "Introduction to APIs",
    "section": "How does it work?",
    "text": "How does it work?"
  },
  {
    "objectID": "04-apis.html#federal-reserve-economic-data-fred-api",
    "href": "04-apis.html#federal-reserve-economic-data-fred-api",
    "title": "Introduction to APIs",
    "section": "Federal Reserve Economic Data (FRED) API",
    "text": "Federal Reserve Economic Data (FRED) API"
  },
  {
    "objectID": "04-apis.html#learning-chech",
    "href": "04-apis.html#learning-chech",
    "title": "Introduction to APIs",
    "section": "Learning Chech",
    "text": "Learning Chech"
  },
  {
    "objectID": "coc.html",
    "href": "coc.html",
    "title": "Code of conduct",
    "section": "",
    "text": "In order to foster a positive and professional learning environment we encourage the following kinds of behaviours:\n\nUse welcoming and inclusive language\nBe respectful of different viewpoints and experiences\nGracefully accept constructive criticism\nFocus on what is best for the community\nShow courtesy and respect towards other community members\n\n(Adapted from The Carpentries’ Code of Conduct)"
  },
  {
    "objectID": "for-tas/02-numpy-notes.html",
    "href": "for-tas/02-numpy-notes.html",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "",
    "text": "Create .ipynb in VS Code\nDifference between markdown cells and code cells\nMarkdown (very briefly)"
  },
  {
    "objectID": "for-tas/02-numpy-notes.html#section-1-jupyter-notebook",
    "href": "for-tas/02-numpy-notes.html#section-1-jupyter-notebook",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "",
    "text": "Create .ipynb in VS Code\nDifference between markdown cells and code cells\nMarkdown (very briefly)"
  },
  {
    "objectID": "for-tas/02-numpy-notes.html#section-2-numpy-arrays",
    "href": "for-tas/02-numpy-notes.html#section-2-numpy-arrays",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Section 2: Numpy arrays",
    "text": "Section 2: Numpy arrays\nInstalling Numpy (can run in the code cells)\npip install numpy\nImporting numpy\nimport numpy as np\nNumpy creation and operations\nnp.arange creates evenly spaced values within a given interval:\nrange_array = np.arange(0, 10, 0.5)\nprint(\"Range array:\", range_array)\nFrom list to array:\nlist_array = np.array([1, 2, 3, 4, 5])\nprint(\"NumPy array:\", list_array)\nIndexing and slicing\nprint(\"Original array:\", range_array)\nprint(\"First element:\", range_array[0])\nprint(\"Last element:\", range_array[-1])\nprint(\"Slicing (elements 3 to 7):\", range_array[2:7])\nrange_array[0] = 99\nprint(\"Update value of first element:\", range_array[0])\nCopies vs Views\n\nChanges in original will be reflected in view and vice versa\nChanges in original will NOT be reflected in copy\n\n# original array\noriginal = np.array([1, 2, 3, 4, 5])\nprint(\"Original array:\", original)\n\n# view of the original array\nview = original.view()\nprint(\"View:\", view)\n\n# copy of the original array\ncopy = original.copy()\nprint(\"Copy:\", copy)\n\n# Modify the original array\noriginal[0] = 99\nprint(\"\\nAfter modifying the original array:\")\nprint(\"Original array:\", original)\nprint(\"View now:\", view)  # reflects the changes\nprint(\"Copy now:\", copy)  # remains unchanged\n\n# Modify the view\nview[1] = 100\nprint(\"\\nAfter modifying the view:\")\nprint(\"Original array:\", original)  # affected\nprint(\"View now:\", view)\nprint(\"Copy now:\", copy)  # remains unchanged\n\n# Modify the copy\ncopy[2] = 200\nprint(\"\\nAfter modifying the copy:\")\nprint(\"Original array:\", original)  # not affected\nprint(\"View now:\", view)  # not affected\nprint(\"Copy now:\", copy)"
  },
  {
    "objectID": "for-tas/02-numpy-notes.html#section-3-two-dimensional-arrays",
    "href": "for-tas/02-numpy-notes.html#section-3-two-dimensional-arrays",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Section 3: Two-dimensional arrays",
    "text": "Section 3: Two-dimensional arrays\narray_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(array_2d)\nprint(\"Shape of the array:\", array_2d.shape)\nprint(\"Size of the array:\", array_2d.size)\nIndices in a 2D array:\narray_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(array_2d[0,0])\nLoading a CSV file to 2D array.\nIn this CSV, the rows represent 7 different sectors and the columns represent the quarters from 2023 Q4, dating back all the way to 2019 Q1.\nEach cell contains the GDP growth of that sector for that quarter, compared to previous year’s quarters.\ngdp_data = np.loadtxt('data/sg-gdp.csv', delimiter=',', dtype=\"float16\")\nnp.set_printoptions(suppress=True)\n\nprint(\"GDP data\")\nprint(gdp_data)\nprint(\"GDP data shape:\", gdp_data.shape)\n\nFind out the mean, standard deviation, max, and mean values.\n\nprint(\"Mean of GDP data:\", np.mean(gdp_data))\nprint(\"Standard deviation of GDP data:\", np.std(gdp_data))\nprint(\"Maximum value in GDP data:\", np.amax(gdp_data))\nprint(\"Minimum value in GDP data:\", np.amin(gdp_data))\n\nFind the mean for each quarter (column-wise operation)\nFind the mean for each sector (row-wise operation)\n\nprint(\"Mean of each quarter:\", np.mean(gdp_data, axis=0))\nprint(\"Mean of each sector:\", np.mean(gdp_data, axis=1))\n\nTranspose the array\n\ntransposed_gdp = np.transpose(gdp_data)\nprint(\"Transposed GDP data shape:\", transposed_gdp.shape)\n\nRetrieve all the negative values.\n\nnegative_growth = gdp_data &lt; 0  \nprint(\"Sectors with negative growth:\\n\", gdp_data[negative_growth])\n\nCalculate the changes every quarter for Sector 1.\n\nThe gdp_data is longitudinal, with each row representing observations for a specific sector over time. This makes growth and contraction trends meaningful to analyze. To calculate changes in the data using NumPy, we can use the numpy.diff() function, which computes the differences between successive values in an array.\nsector1_array = gdp_data[0, :] # first row, all columns\nprint(\"sector1_array:\", sector1_array)\n\nsector1_changes = np.diff(sector1_array)\nprint(\"\\nsector1_changes:\", sector1_changes)\nprint(\"\\nsector1_changes absolute change:\", np.absolute(sector1_changes))\nNumPy financial functions\nCalculate the future value of $1000 invested for 3 years at a 5.0% average annual rate of return.\nnp.fv(rate=0.05, nper=3, pmt=0, pv=-1000)\nBy convention, the negative sign represents cash flow out (i.e. money not available today).\nExample 2:\nYou have a loan of 10,000 SGD at 9% annual interest. How long would it take to pay-off the load if your monthly payment is at 750?\nnp.round(npf.nper(0.09/12, -750, 10000), 5)\n# divided by 12, because the interest is annual but the payment is monthly"
  },
  {
    "objectID": "for-tas/02-numpy-notes.html#section-4-visualizing-array-contents-matplotlib",
    "href": "for-tas/02-numpy-notes.html#section-4-visualizing-array-contents-matplotlib",
    "title": "Introduction to Numpy & Matplotlib",
    "section": "Section 4: Visualizing Array contents (Matplotlib)",
    "text": "Section 4: Visualizing Array contents (Matplotlib)\nSimple Lineplot\nplt.plot(gdp_data)\nplt.xlabel('Values')\nplt.ylabel('Sectors')\nplt.title('Values Over Quarters')\nplt.legend()\nplt.grid()\nplt.show()\nLineplot for each sector\ntransposed = gdp_data.T\nfor sector in range(7):\n    plt.plot(transposed[:, sector], label=f'Sector {sector + 1}')\n\nplt.legend()\nplt.grid()\nplt.show()\nBoxplot\ntransposed = gdp_data.T\n\nplt.boxplot(transposed)\nplt.grid()\nplt.show()"
  }
]