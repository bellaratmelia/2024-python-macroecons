---
title: "Introduction to Numpy & Matplotlib"
author: "Bella Ratmelia"
format: revealjs
---

## Recap from yesterday

-   Introduction to Visual Studio

-   Introduction to Python

-   Handling Lists

-   Handling Loops and Conditionals

## Overview for today

-   Introduction to Jupyter Notebook

-   Python libraries: Extending Python's functionality

-   NumPy for more efficient numerical computing

-   Matplotlib: Data visualization

# Section 1: Jupyter Notebook

## Refresher: .py and .ipynb
::::: columns
::: {.column width="55%"}
If it's a **.py** file...

![](images/py-script.png)

For "production" uses e.g., creating apps, industrial deployments; Executing the file will run all the codes inside the file.
:::

::: {.column width="45%"}
If it's a **.ipynb** file...

![](images/ipynb-script.png)

Great for quick experiments or teaching / presentation; Codes will be executed on per-block basis
:::
:::::

# Section 2: Numpy Arrays

## What's Numpy?
NumPy is the fundamental package for scientific computing in Python.

It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.[^1]

[^1]: <https://numpy.org/doc/stable/user/whatisnumpy.html>

-   Faster and more memory-efficient than Python lists

-   Optimized for large-scale numerical operations (better than list)

## What's a Python library?

-   Python libraries or packages are essentially reusable sets of code that can be imported into your environment to extend functionality.
-   Before using them, most libraries must first be installed and then imported.
-   However, some libraries are part of the Python Standard Library, meaning they don't need to be installedâ€”just imported. For example, `time`.

```{python}
#| echo: true
#| output: false
import numpy as np # giving numpy a shorter "nickname"
import time
```

## Numpy vs Lists

::::: columns
::: {.column width="50%"}
**Lists**

-   dynamic size upon creation; you can change the size of a list anytime.
-   all items inside list can be of **different** data types.
-   not optimized for scientific/mathematical operations
:::

::: {.column width="50%"}
**NumPy Arrays**

-   fixed size upon creation; changing the size will create new array and delete the original.
-   all items inside arrays must be the **same** data types.
-   facilitate advanced mathematical and other types of operations on large numbers of data, and thus more efficient.
-   a lot scientific/mathematical libraries are build on top of numpy (including pandas!)
:::
:::::

## Numpy vs Lists: Performance comparison

Imagine we have a million numbers to square. We'll store them in both a list and an array, then compare their processing speeds.

```{python}
#| echo: true

# Creating large datasets
list_data = list(range(1000000))
numpy_data = np.arange(1000000)

# Comparing operation speed
start = time.time()
list_result = [x**2 for x in list_data]
list_time = time.time() - start

start = time.time()
numpy_result = numpy_data**2
numpy_time = time.time() - start

print(f"List took {list_time:.4f} seconds to finish the operation.")
print(f"NumPy took {numpy_time:.4f} seconds to finish the operation.")
```

## Numpy vs Lists: Sum and products

-   When you add two lists together, the contents will be concatenated
-   When you do add two arrays together, the contents will be summed

::::: columns
::: {.column width="50%"}
Lists

```{python}
#| echo: true
list_1 = [1, 2, 3, 4, 5]
list_2 = [10, 20, 30, 40, 50]

print(list_1 + list_2)
# list_1 * list_2 will give an error
```
:::

::: {.column width="50%"}
Numpy Arrays

```{python}
#| echo: true
array_1 = np.array([1, 2, 3, 4, 5])
array_2 = np.array([10, 20, 30, 40, 50])

print("Sum:", array_1 + array_2)
print("Product:", array_1 * array_2)
```
:::
:::::

## Numpy creation and operations

As seen in the example, we can use `np.arange()` to create an array from scratch. We can also create an array from a list using `np.array()` like this: `np.array([1, 2, 3, 4, 5])`

Most operations we perform on lists can also be done with arrays, including:

-   Slicing
-   Indexing
-   Sorting
-   Creating copies or views (with important differences between them!)

Let's try these!

## Learning Check #1

Create two arrays called `odd_numbers` and `even_numbers` that only contains odd numbers and even numbers from 1 to 20 respectively.

```{python}
#| code-fold: true
#| echo: true

odd_numbers = np.arange(1, 21, 2)
even_numbers = np.arange(0, 21, 2)
print("Odd numbers:", odd_numbers)
print("Even numbers:", even_numbers)

```

# Section 3: 2-dimensional Arrays

## Array can contain columns and rows too!

```{python}
#| echo: true
array_2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(array_2d)
print("Shape of the array:", array_2d.shape)
print("Size of the array:", array_2d.size)
```

## Indices in a 2D array

![](images/numpy_indices.png)

## Loading from a CSV into a 2D array

Let's load our data `sg-gdp.csv` into a 2D array!

In this CSV:

-   The rows represent 7 different sectors
-   The columns represent the quarters from 2023 Q4, dating back all the way to 2019 Q1.
-   Each cell contains the GDP growth of that sector for that quarter, compared to previous year's quarters.

```{python}
#| echo: true
#| output-location: slide
gdp_data = np.loadtxt('data/sg-gdp.csv', delimiter=',', dtype="float16")
np.set_printoptions(suppress=True)

print("GDP data")
print(gdp_data)
print("GDP data shape:", gdp_data.shape)
```

Remember, the shape will be printed as `(row, column)`.

## 2D array operations

Let's see if we can complete the following tasks:

1.  Find out the mean, standard deviation, max, and mean values.
2.  Find the mean for each quarter (column-wise operation)
3.  Find the mean for each sector (row-wise operation)
4.  Transpose the array
5.  Retrieve all the negative values.
6.  Calculate the changes every quarter for Sector 1.

## Axis Operations

![](images/axes_operations.png)

## Numpy Financial

The `numpy-financial` package is a collection of elementary financial functions. It's a relatively tiny package, but useful if you need to do some financial calculations.

![](images/numpy-financial.jpg)

Let's try some of these!

## Learning Check #2

The `gdp_data` is longitudinal, with each row representing observations for a specific sector over time. This makes growth and contraction trends meaningful to analyze. To calculate changes in the data using NumPy, we can use the numpy.diff() function, which computes the differences between successive values in an array.

1.  Calculate the changes for each quarter for all sector. Save this into an array called `sector_changes`.
2.  Afterwards, find the largest changes in `sector_changes`.

```{python}
#| echo: true
#| code-fold: true
#| output-location: slide

sector_changes = np.diff(gdp_data)
print("sector_changes:", sector_changes)
print("\nsector_changes shape:", sector_changes.shape)

print("\nLargest change:", np.amax(sector_changes))

```

# Section 4: Visualizing Array contents

## Visualization libraries: Matplotlib and Seaborn
There are multiple visualization libraries for python. We will try out Matplotlib and Seaborn (for next session)

Primary differences between the two:

::::: columns
::: {.column style="width:50%; font-size:0.8em;"}
**Matplotlib**

- A foundational Python library for static, interactive, and animated visualizations.
- Highly customizable, offering full control over plot elements (axes, ticks, legends).
- Supports a wide range of plots, from simple line charts to complex 3D visualizations and heatmaps.
- Can be challenging for beginners due to its flexibility.
- Ideal for precise control and building complex plots.
:::

::: {.column style="width:50%; font-size:0.8em;"}
**Seaborn**

- Built on Matplotlib to simplify statistical visualization with attractive designs.
- Offers high-level abstractions for complex plots (e.g., pair plots, heatmaps) with minimal effort.
- Supports visualizing variable relationships and statistical summaries (e.g., regression, categorical plots).
- Easier for beginners to create high-quality visuals quickly.
- Best for data exploration and statistical analysis with minimal setup.
:::
:::::

## Refresher: Data types in social sciences and economics research

::::: columns
::: {.column width="50%"}
Non-Continuous Data

-   Nominal/Categorical: Non-ordered, non-numerical data, used to represent qualitative attribute.
-   Ordinal: Ordered non-numerical data.
-   Discrete: Numerical data that can only take specific value (usually integers)
-   Binary: Nominal data with only two possible outcome.
:::

::: {.column width="50%"}
Continuous Data

-   Interval: Numerical data that can take any value within a range. [It does not have a "true zero".]{.underline}
-   Ratio: Numerical data that can take any value within a range. [it has a "true zero".]{.underline}
:::
:::::

## Chart types and their purposes

-   Bar charts: Comparing categories
-   Line charts: Trends or progress over time
-   Scatter plots: Relationships between (continuous) variables
-   Pie charts: Parts of a whole 
    -  Depending on who you ask, some may argue that percent barchart is better at this.
-   Box plots: Distribution and outliers

## Anatomy of a matplotlib graph

::::: columns
::: {.column}
![](images/matplotlib-anatomy.webp)
:::

::: {.column}
**Useful resources:**

-  [Matplotlib cheatsheets](https://matplotlib.org/cheatsheets/) - This is more beginner-friendly
-  [Quick start guide](https://matplotlib.org/stable/users/explain/quick_start.html)
-  [Python Graph Gallery](https://python-graph-gallery.com/matplotlib/)

:::
:::::

## Matplotlib: Simple Lineplot

Let's try to visualize the contents of `gdp_data`!

```{python}
#| echo: false
import matplotlib.pyplot as plt

plt.plot(gdp_data)
plt.xlabel('Values')
plt.ylabel('Sectors')
plt.title('Values Over Quarters')
plt.legend()
plt.grid()
plt.show()
```

## Matplotlib: Individual Line Plots

Let's create different lines for each sector!

```{python}
transposed = gdp_data.T
for sector in range(7):
    plt.plot(transposed[:, sector], label=f'Sector {sector + 1}')

plt.legend()
plt.grid()
plt.show()
```

## Matplotlib: Histogram

Let's see if there's any outlier growths or contractions on each sectors over the quarters!

```{python}
transposed = gdp_data.T

plt.boxplot(transposed)
plt.grid()
plt.show()
```

## Learning Check #3

Using the `sg-gdp.csv` data loaded into a NumPy array:

1.  Create a line plot showing the GDP growth over time for the first two sectors only
2.  Add appropriate labels, a title, and a legend to the plot.

```{python}
#| code-fold: true
#| echo: true
#| output-location: slide

two_sectors = gdp_data[:2, :] #[first two rows, all columns]
sector_number = 1 
for sector in two_sectors:
    plt.plot(sector, label = "Sector " + str(sector_number))
    sector_number = sector_number + 1 #increase sector number by 1

plt.legend()
plt.grid()
plt.show()

```

# End of Session 2!

We have covered: jupyter notebook, numpy, and matplotlib!